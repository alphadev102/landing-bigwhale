{"version":3,"file":"static/js/2359.a7e2ac33.chunk.js","mappings":"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","sources":["../node_modules/ethers/node_modules/@ethersproject/bignumber/src.ts/fixednumber.ts","../node_modules/ethers/node_modules/@ethersproject/constants/src.ts/strings.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/ankr-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/ethers/src.ts/_version.ts","../node_modules/ethers/src.ts/ethers.ts","../node_modules/ethers/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") { fraction = \"0\"; }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        logger.checkNew(new.target, FixedNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n","// NFKC (composed)             // (decomposed)\nexport const EtherSymbol = \"\\u039e\";  // \"\\uD835\\uDF63\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\nexport interface WebSocketLike {\n    onopen: (...args: Array<any>) => any;\n    onmessage: (...args: Array<any>) => any;\n    onerror: (...args: Array<any>) => any;\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string | WebSocketLike, network?: Networkish) {\n\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        if (typeof(url) === \"string\") {\n            super(url, network);\n        } else {\n            super(\"_websocket\", network);\n        }\n\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        } else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this.websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket(): WebSocketLike { return this._websocket; }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this.websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this.websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this.websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this.websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this.websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\nimport { Network } from \"@ethersproject/networks\";\n\nimport { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport type { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\n\nfunction getHost(name: string): string {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\n\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    readonly apiKey: string;\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        if (apiKey == null) { apiKey = defaultApiKey; }\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        logger.checkNew(new.target, EtherscanProvider);\n\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        logger.checkNew(new.target, FallbackProvider);\n\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    AnkrProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","export const version = \"wordlists/5.6.0\";\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","export const version = \"ethers/5.6.5\";\n","\"use strict\";\n\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\n\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\n\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\n\nimport * as constants from \"@ethersproject/constants\";\n\nimport * as providers from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\n\nimport { Wordlist, wordlists} from \"@ethersproject/wordlists\";\n\nimport * as utils from \"./utils\";\n\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\n\n////////////////////////\n// Types\n\nimport { BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike, Signature } from \"@ethersproject/bytes\";\nimport { Transaction, UnsignedTransaction } from \"@ethersproject/transactions\";\n\n\n////////////////////////\n// Compile-Time Constants\n\n// This is generated by \"npm run dist\"\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\n////////////////////////\n// Types\n\nimport {\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface\n} from \"@ethersproject/contracts\";\n\n\n////////////////////////\n// Exports\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n};\n\n","\"use strict\";\n\n// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\n\nimport * as ethers from \"./ethers\";\n\ntry {\n    const anyGlobal = (window as any);\n\n    if (anyGlobal._ethers == null) {\n        anyGlobal._ethers = ethers;\n    }\n} catch (error) { }\n\nexport { ethers };\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n} from \"./ethers\";\n"],"names":["logger","Logger","version","_constructorGuard","Zero","BigNumber","NegativeOne","throwFault","message","fault","operation","value","params","undefined","throwError","zeros","length","getMultiplier","decimals","toNumber","e","substring","throwArgumentError","formatFixed","multiplier","negative","lt","mul","fraction","mod","toString","match","whole","div","parseFixed","comps","split","wholeValue","fractionValue","wei","add","FixedFormat","constructorGuard","signed","width","this","name","String","_multiplier","Object","freeze","parseInt","check","key","type","defaultValue","FixedNumber","hex","format","checkNew","_hex","_value","_isFixedNumber","other","_checkFormat","a","b","fromValue","sub","push","result","from","hasFraction","isNegative","subUnsafe","ONE","toFormat","addUnsafe","factor","bump","BUMP","mulUnsafe","floor","divUnsafe","fromTwos","toTwos","toHexString","hexZeroPad","parseFloat","fromString","isBigNumberish","fixedFormat","numeric","decimal","arrayify","Error","isBytes","fromBytes","error","code","EtherSymbol","WS","WebSocket","NextId","WebSocketProvider","url","network","_pollingInterval","_wsReady","defineReadOnly","connection","websocket","onopen","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","request","callback","emit","action","response","provider","method","_subs","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","blockNumber","rid","Promise","resolve","reject","stringify","jsonrpc","tag","param","subIdPromise","_subIds","all","then","subId","event","_subscribe","number","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","listenerCount","readyState","onerror","close","JsonRpcProvider","StaticJsonRpcProvider","_super","detectNetwork","_network","UrlJsonRpcProvider","apiKey","checkAbstract","getStatic","address","defaultApiKey","AlchemyWebSocketProvider","AlchemyProvider","replace","host","arguments","allowGzip","throttleCallback","attempt","showThrottleMessage","getHost","AnkrProvider","projectSecret","user","password","CloudflareProvider","perform","blockTag","getTransactionPostData","transaction","gasLimit","gasPrice","maxFeePerGs","maxPriorityFeePerGas","nonce","hexValue","hexlify","accessListify","map","set","storageKeys","join","getResult","status","toLowerCase","indexOf","throttleRetry","getJsonResult","checkLogTag","checkError","isHexString","body","responseText","EtherscanProvider","getBaseUrl","module","query","reduce","accum","baseUrl","apikey","post","getPostUrl","getUrl","getPostData","procFunc","throttleSlotInterval","isCommunityResource","payloadStr","headers","fetchJson","deepCopy","fetch","position","signedTransaction","catch","boolean","includeTransactions","txhash","transactionHash","postData","args","fromBlock","toBlock","topics","topic0","logs","blocks","i","blockHash","getBlock","ethusd","addressOrName","startBlock","endBlock","resolveName","startblock","endblock","sort","tx","creates","contractAddress","item","transactionResponse","timeStamp","timestamp","BaseProvider","shuffled","array","slice","j","Math","random","tmp","now","Date","getTime","checkNetworks","networks","chainId","ensAddress","median","values","maxDelta","middle","abs","serialize","Array","isArray","v","nextRid","stall","duration","cancel","timer","promise","clearTimeout","setTimeout","getPromise","wait","func","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","get","start","done","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","shallowCopy","confirmations","transactions","quorum","tally","count","normalizedTally","waitForSync","poll","cancelled","oncePoll","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","getLogs","FallbackProvider","providers","providerConfigs","configOrProvider","index","Provider","stallTimeout","priority","total","networkOrReady","getNetwork","sendTransaction","results","getBlockNumber","first","t0","inflightWeight","runner","staller","backend","waiting","race","errors","errorCode","props","reason","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","projectId","apiKeyObj","assertArgument","argument","JsonRpcBatchProvider","_nextId","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","homestead","ropsten","rinkeby","goerli","PocketProvider","n","applicationId","loadBalancer","applicationSecretKey","getDefaultProvider","options","_defaultProvider","Web3Provider","_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","off","_logLevel","_globalLogger","LogLevel","ErrorCode","_normalizeError","missing","form","fromCharCode","_checkNormalize","HEX","enumerable","writable","logLevel","level","apply","_log","levels","DEBUG","INFO","WARNING","makeError","UNKNOWN_ERROR","messageDetails","Uint8Array","NUMERIC_FAULT","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","INVALID_ARGUMENT","condition","UNSUPPORTED_OPERATION","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","target","kind","censorship","permanent","globalLogger","isHexable","addSlice","prototype","call","isInteger","constructor","checkSafeUint53","unshift","allowMissingPrefix","hexPad","UnicodeNormalizationForm","Utf8ErrorReason","ignoreFunc","offset","bytes","output","badCodepoint","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","ignore","OVERLONG","toUtf8Bytes","str","current","checkNormalize","charCodeAt","c2","pair","text","sha3","object","Wordlist","locale","mnemonic","words","wordlist","word","getWord","getWordIndex","lang","loadWords","langEn","register","wordlists","en","anyGlobal","window","_ethers","ethers"],"sourceRoot":""}