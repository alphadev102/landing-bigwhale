{"version":3,"file":"static/js/619.f8668ba1.chunk.js","mappings":"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","sources":["../node_modules/ethers/node_modules/@ethersproject/constants/src.ts/strings.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/ankr-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/ethers/node_modules/@ethersproject/providers/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/ethers/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/ethers/src.ts/_version.ts","../node_modules/ethers/src.ts/ethers.ts","../node_modules/ethers/src.ts/index.ts"],"sourcesContent":["// NFKC (composed)             // (decomposed)\nexport const EtherSymbol = \"\\u039e\";  // \"\\uD835\\uDF63\";\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arb-goerli.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-goerli\":\n                host = \"opt-goerli.g.alchemy.com/v2/\"\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\nimport { Network } from \"@ethersproject/networks\";\n\nimport { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport type { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\n\nfunction getHost(name: string): string {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\n\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    readonly apiKey: string;\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        if (apiKey == null) { apiKey = defaultApiKey; }\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || typeof(result.message) !== \"string\" || !result.message.match(/^OK/)) {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string | null;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || null);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"sepolia\":\n                return \"https:/\\/api-sepolia.etherscan.io\";\n            case \"matic\":\n                return \"https:/\\/api.polygonscan.com\";\n            case \"maticmum\":\n                return \"https:/\\/api-testnet.polygonscan.com\";\n            case \"arbitrum\":\n                return \"https:/\\/api.arbiscan.io\";\n            case \"arbitrum-goerli\":\n                return \"https:/\\/api-goerli.arbiscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            case \"optimism-goerli\":\n                return \"https:/\\/api-goerli-optimistic.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey == null);\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"sepolia\":\n                host = \"sepolia.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-goerli\":\n                host = \"optimism-goerli.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arbitrum-goerli.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\n\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: true,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (apiKey == null) {\n            apiKeyObj.applicationId = defaultApplicationId;\n\n        } else if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n\n        } else if (apiKey.applicationId) {\n            apiKeyObj.applicationId = apiKey.applicationId;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"kovan\":\n                host = \"poa-kovan.gateway.pokt.network\";\n                break;\n            case \"matic\":\n                host = \"poly-mainnet.gateway.pokt.network\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai-rpc.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n\n        const connection: ConnectionInfo = { headers: { }, url };\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationId);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\": case \"https\":\n                    return new JsonRpcProvider(network);\n                case \"ws\": case \"wss\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    AnkrProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","export const version = \"wordlists/5.6.0\";\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","export const version = \"ethers/5.7.2\";\n","\"use strict\";\n\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\n\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\n\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\n\nimport * as constants from \"@ethersproject/constants\";\n\nimport * as providers from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\n\nimport { Wordlist, wordlists} from \"@ethersproject/wordlists\";\n\nimport * as utils from \"./utils\";\n\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\n\n////////////////////////\n// Types\n\nimport type { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike, Signature } from \"@ethersproject/bytes\";\nimport { Transaction, UnsignedTransaction } from \"@ethersproject/transactions\";\n\n\n////////////////////////\n// Compile-Time Constants\n\n// This is generated by \"npm run dist\"\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\n////////////////////////\n// Types\n\nimport {\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface\n} from \"@ethersproject/contracts\";\n\n\n////////////////////////\n// Exports\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    TypedDataDomain,\n    TypedDataField,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n};\n\n","\"use strict\";\n\n// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\n\nimport * as ethers from \"./ethers\";\n\ntry {\n    const anyGlobal = (window as any);\n\n    if (anyGlobal._ethers == null) {\n        anyGlobal._ethers = ethers;\n    }\n} catch (error) { }\n\nexport { ethers };\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    TypedDataDomain,\n    TypedDataField,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n} from \"./ethers\";\n"],"names":["EtherSymbol","logger","Logger","version","defaultApiKey","AlchemyWebSocketProvider","network","apiKey","provider","AlchemyProvider","url","connection","replace","defineReadOnly","this","WebSocketProvider","throwArgumentError","host","name","arguments","allowGzip","throttleCallback","attempt","showThrottleMessage","Promise","resolve","UrlJsonRpcProvider","getHost","AnkrProvider","projectSecret","user","password","CloudflareProvider","method","params","_super","perform","blockTag","block","number","getTransactionPostData","transaction","result","key","value","type","gasLimit","gasPrice","maxFeePerGs","maxPriorityFeePerGas","nonce","hexValue","hexlify","accessListify","map","set","address","storageKeys","join","getResult","status","message","match","error","Error","JSON","stringify","toLowerCase","indexOf","throttleRetry","getJsonResult","jsonrpc","code","data","checkLogTag","parseInt","substring","checkError","e","isHexString","throwError","body","responseText","EtherscanProvider","getBaseUrl","module","query","Object","keys","reduce","accum","baseUrl","apikey","post","getPostUrl","getUrl","payload","getPostData","procFunc","emit","action","request","throttleSlotInterval","isCommunityResource","payloadStr","headers","fetchJson","response","deepCopy","fetch","tag","position","hex","signedTransaction","catch","boolean","includeTransactions","txhash","transactionHash","postData","args","filter","fromBlock","toBlock","topics","length","topic0","logs","blocks","i","log","blockHash","blockNumber","getBlock","hash","parseFloat","ethusd","addressOrName","startBlock","endBlock","resolveName","startblock","endblock","sort","tx","forEach","creates","contractAddress","item","formatter","transactionResponse","timeStamp","timestamp","BaseProvider","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","operation","projectId","apiKeyObj","assertArgument","argument","JsonRpcBatchProvider","id","_nextId","_pendingBatch","inflightRequest","reject","promise","push","_pendingBatchAggregator","setTimeout","batch","inflight","then","index","JsonRpcProvider","NodesmithProvider","warn","defaultApplicationId","PocketProvider","applicationId","loadBalancer","applicationSecretKey","getDefaultProvider","options","n","getNetwork","_defaultProvider","FallbackProvider","Web3Provider","_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","off","_logLevel","_globalLogger","LogLevel","ErrorCode","_normalizeError","missing","form","normalize","String","fromCharCode","_checkNormalize","HEX","defineProperty","enumerable","writable","logLevel","level","console","apply","_log","levels","DEBUG","INFO","WARNING","makeError","errors","UNKNOWN_ERROR","messageDetails","Uint8Array","toString","reason","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","INVALID_ARGUMENT","condition","UNSUPPORTED_OPERATION","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","target","kind","censorship","permanent","globalLogger","isHexable","toHexString","addSlice","array","slice","Array","prototype","call","isInteger","isBytes","constructor","v","arrayify","checkSafeUint53","unshift","allowMissingPrefix","hexPad","UnicodeNormalizationForm","Utf8ErrorReason","ignoreFunc","offset","bytes","output","badCodepoint","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","freeze","ignore","OVERLONG","toUtf8Bytes","str","current","checkNormalize","c","charCodeAt","c2","pair","text","sha3","object","Wordlist","locale","checkAbstract","mnemonic","split","words","wordlist","word","getWord","getWordIndex","lang","loadWords","check","langEn","register","wordlists","en","anyGlobal","window","_ethers","ethers"],"sourceRoot":""}