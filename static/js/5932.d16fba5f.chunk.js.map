{"version":3,"file":"static/js/5932.d16fba5f.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/@ethersproject/providers/src.ts/ankr-provider.ts","../node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/web3-provider.ts","../node_modules/@ethersproject/providers/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\" ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [ \"ropsten\" ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"networks/5.7.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    if (options.fetchOptions != null) {\n        const opts = options.fetchOptions;\n        if (opts.mode) { request.mode = <RequestMode>(opts.mode); }\n        if (opts.cache) { request.cache = <RequestCache>(opts.cache); }\n        if (opts.credentials) { request.credentials = <RequestCredentials>(opts.credentials); }\n        if (opts.redirect) { request.redirect = <RequestRedirect>(opts.redirect); }\n        if (opts.referrer) { request.referrer = opts.referrer; }\n    }\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    fetchOptions?: Record<string, string>;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"web/5.7.0\";\n","export const version = \"providers/5.6.8\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: Formatter.allowNull(address),\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\nconst MAX_CCIP_REDIRECTS = 10;\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    _lastBlockNumber: number\n    _inflight: boolean;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = arrayify(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>) {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return hexConcat(result);\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    _supportsEip2544: null | Promise<boolean>;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    supportsWildcard(): Promise<boolean> {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return false; }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n\n        return this._supportsEip2544;\n    }\n\n    async _fetch(selector: string, parameters?: string): Promise<null | string> {\n\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            ccipReadEnabled: true,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        // Wildcard support; use EIP-2544 to resolve the request\n        let parseBytes = false;\n        if (await this.supportsWildcard()) {\n            parseBytes = true;\n\n            // selector(\"resolve(bytes,bytes)\")\n            tx.data = hexConcat([ \"0x9061b923\", encodeBytes([ dnsEncode(this.name), tx.data ]) ]);\n        }\n\n        try {\n            let result = await this.provider.call(tx);\n            if ((arrayify(result).length % 32) === 4) {\n                logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                    transaction: tx, data: result\n                });\n            }\n            if (parseBytes) { result = _parseBytes(result, 0); }\n            return result;\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        const result = await this._fetch(selector, parameters);\n        if (result != null) { return _parseBytes(result, 0); }\n        return null;\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const result = await this._fetch(\"0x3b3b57de\");\n\n                // No address\n                if (result === \"0x\" || result === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(result);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx), 0);\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // IPNS (CID: 1, Type: libp2p-key)\n        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipns) {\n            const length = parseInt(ipns[3], 16);\n            if (ipns[4].length === length * 2) {\n                return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n        if (skynet) {\n            if (skynet[1].length === (34 * 2)) {\n                // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                const urlSafe: Record<string, string> = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                return \"sia:/\\/\" + hash;\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n    _maxFilterBlockRange: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n    disableCcipRead: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.disableCcipRead = false;\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    async ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                value.status = response.statusCode;\n                return value;\n            });\n\n            if (result.data) { return result.data; }\n\n            const errorMessage = (result.message || \"unknown error\");\n\n            // 4xx indicates the result is not present; stop\n            if (result.status >= 400 && result.status < 500) {\n                return logger.throwError(`response not found during CCIP fetch: ${ errorMessage }`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n            }\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        return logger.throwError(`error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, Logger.errors.SERVER_ERROR, {\n            urls, errorMessages\n        });\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    // We only allow a single getLogs to be in-flight at a time\n                    if (!event._inflight) {\n                        event._inflight = true;\n\n                        // Filter from the last known event; due to load-balancing\n                        // and some nodes returning updated block numbers before\n                        // indexing events, a logs result with 0 entries cannot be\n                        // trusted and we must retry a range which includes it again\n                        const filter = event.filter;\n                        filter.fromBlock = event._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n\n                        // Prevent fitler ranges from growing too wild\n                        if (filter.toBlock - this._maxFilterBlockRange > filter.fromBlock) {\n                            filter.fromBlock = filter.toBlock - this._maxFilterBlockRange;\n                        }\n\n                        const runner = this.getLogs(filter).then((logs) => {\n                            // Allow the next getLogs\n                            event._inflight = false;\n\n                            if (logs.length === 0) { return; }\n\n                            logs.forEach((log: Log) => {\n                                // Only when we get an event for a given block number\n                                // can we trust the events are indexed\n                                if (log.blockNumber > event._lastBlockNumber) {\n                                    event._lastBlockNumber = log.blockNumber;\n                                }\n\n                                // Make sure we stall requests to fetch blocks and txs\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\n                                this.emit(filter, log);\n                            });\n                        }).catch((error: Error) => {\n                            this.emit(\"error\", error);\n\n                            // Allow another getLogs (the range was not updated)\n                            event._inflight = false;\n                        });\n                        runners.push(runner);\n                    }\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string> {\n        if (attempt >= MAX_CCIP_REDIRECTS) {\n            logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                redirects: attempt, transaction\n            });\n        }\n\n        const txSender = transaction.to;\n\n        const result = await this.perform(\"call\", { transaction, blockTag });\n\n        // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n        if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n            try {\n                const data = hexDataSlice(result, 4);\n\n                // Check the sender of the OffchainLookup matches the transaction\n                const sender = hexDataSlice(data, 0, 32);\n                if (!BigNumber.from(sender).eq(txSender)) {\n                    logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                // Read the URLs from the response\n                const urls: Array<string> = [];\n                const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                const urlsData = hexDataSlice(data, urlsOffset + 32);\n                for (let u = 0; u < urlsLength; u++) {\n                    const url = _parseString(urlsData, u * 32);\n                    if (url == null) {\n                        logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    urls.push(url);\n                }\n\n                // Get the CCIP calldata to forward\n                const calldata = _parseBytes(data, 64);\n\n                // Get the callbackSelector (bytes4)\n                if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                    logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n                const callbackSelector = hexDataSlice(data, 96, 100);\n\n                // Get the extra data to send back to the contract as context\n                const extraData = _parseBytes(data, 128);\n\n                const ccipResult = await this.ccipReadFetch(<Transaction>transaction, calldata, urls);\n                if (ccipResult == null) {\n                    logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                const tx = {\n                    to: txSender,\n                    data: hexConcat([ callbackSelector, encodeBytes([ ccipResult, extraData ]) ])\n                };\n\n                return this._call(tx, blockTag, attempt + 1);\n\n            } catch (error) {\n                if (error.code === Logger.errors.SERVER_ERROR) { throw error; }\n            }\n        }\n\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params: { transaction, blockTag }, result, error\n            });\n        }\n\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const resolved = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag),\n            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n        });\n        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0: -1);\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await this._getResolver(currentName, \"getResolver\");\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new Resolver(this, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n\n    }\n\n    async _getResolver(name: string, operation?: string): Promise<string> {\n        if (operation == null) { operation = \"ENS\"; }\n\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation, network: network.name }\n            );\n        }\n\n        try {\n            // keccak256(\"resolver(bytes32)\")\n            const addrData = await this.call({\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            });\n            return this.formatter.callAddress(addrData);\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n        }\n\n        return null;\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resolver\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddr = await this._getResolver(node, \"lookupAddress\");\n        if (resolverAddr == null) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        const name = _parseString(await this.call({\n            to: resolverAddr,\n            data: (\"0x691f3431\" + namehash(node).substring(2))\n        }), 0);\n\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(node, \"getAvatar\");\n            if (!resolverAddress) { return null; }\n\n            // Try resolving the avatar against the addr.reverse resolver\n            resolver = new Resolver(this, resolverAddress, node);\n            try {\n                const avatar = await resolver.getAvatar();\n                if (avatar) { return avatar.url; }\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n            }\n\n            // Try getting the name and performing forward lookup; allowing wildcards\n            try {\n                // keccak(\"name(bytes32)\")\n                const name = _parseString(await this.call({\n                    to: resolverAddress,\n                    data: (\"0x691f3431\" + namehash(node).substring(2))\n                }), 0);\n                resolver = await this.getResolver(name);\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n                return null;\n            }\n\n        } else {\n            // ENS name; forward lookup with wildcard\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction spelunk(value: any, requireData: boolean): null | { message: string, data: null | string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data: null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction checkError(method: string, error: any, params: any): any {\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) { return result.data; }\n\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) { result = spelunk(error, false); }\n\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n\n    // @TODO: Should we spelunk for message too?\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n        return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            address.toLowerCase(),\n            JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue(BigNumber.from((<any>transaction)[key]));\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\nexport interface WebSocketLike {\n    onopen: (...args: Array<any>) => any;\n    onmessage: (...args: Array<any>) => any;\n    onerror: (...args: Array<any>) => any;\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string | WebSocketLike, network?: Networkish) {\n\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        if (typeof(url) === \"string\") {\n            super(url, network);\n        } else {\n            super(\"_websocket\", network);\n        }\n\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        } else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this.websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket(): WebSocketLike { return this._websocket; }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this.websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this.websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this.websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this.websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this.websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\nimport { Network } from \"@ethersproject/networks\";\n\nimport { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport type { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\n\nfunction getHost(name: string): string {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\n\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    readonly apiKey: string;\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        if (apiKey == null) { apiKey = defaultApiKey; }\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport { Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Exported Types\nexport type ExternalProvider = {\n    isMetaMask?: boolean;\n    isStatus?: boolean;\n    host?: string;\n    path?: string;\n    sendAsync?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    send?: (request: { method: string, params?: Array<any> }, callback: (error: any, response: any) => void) => void\n    request?: (request: { method: string, params?: Array<any> }) => Promise<any>\n}\n\nlet _nextId = 1;\n\nexport type JsonRpcFetchFunc = (method: string, params?: Array<any>) => Promise<any>;\n\ntype Web3LegacySend = (request: any, callback: (error: Error, response: any) => void) => void;\n\nfunction buildWeb3LegacyFetcher(provider: ExternalProvider, sendFunc: Web3LegacySend) : JsonRpcFetchFunc {\n    const fetcher = \"Web3LegacyFetcher\";\n\n    return function(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n\n            sendFunc(request, (error, response) => {\n\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n\n                    return reject(error);\n                }\n\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    (<any>error).code = response.error.code;\n                    (<any>error).data = response.error.data;\n                    return reject(error);\n                }\n\n                resolve(response.result);\n            });\n        });\n    }\n}\n\nfunction buildEip1193Fetcher(provider: ExternalProvider): JsonRpcFetchFunc {\n    return function(method: string, params: Array<any>): Promise<any> {\n        if (params == null) { params = [ ]; }\n\n        const request = { method, params };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n\n            return response;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n\n            throw error;\n        });\n    }\n}\n\nexport class Web3Provider extends JsonRpcProvider {\n    readonly provider: ExternalProvider;\n    readonly jsonRpcFetchFunc: JsonRpcFetchFunc;\n\n    constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish) {\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n\n        let path: string = null;\n        let jsonRpcFetchFunc: JsonRpcFetchFunc = null;\n        let subprovider: ExternalProvider = null;\n\n        if (typeof(provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n\n            subprovider = provider;\n\n            if (provider.request) {\n                if (path === \"\") { path = \"eip-1193:\"; }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n\n            if (!path) { path = \"unknown:\"; }\n        }\n\n        super(path, network);\n\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\": case \"https\":\n                    return new JsonRpcProvider(network);\n                case \"ws\": case \"wss\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    AnkrProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n"],"names":["logger","Logger","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","push","error","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","provider","indexOf","name","CloudflareProvider","cloudflare","AnkrProvider","ankr","length","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","chainId","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","throwArgumentError","value","defaultProvider","getUrl","href","request","method","headers","body","undefined","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetchOptions","opts","fetch","response","arrayBuffer","forEach","key","toLowerCase","keys","get","statusCode","status","statusMessage","statusText","arrayify","Uint8Array","staller","duration","Promise","resolve","setTimeout","bodyify","type","isBytesLike","split","trim","toUtf8String","hexlify","fetchJson","connection","json","processFunc","toUtf8Bytes","updated","shallowCopy","Object","filter","k","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","errorPassThrough","allow304","timeout","String","allowGzip","user","password","substring","allowInsecureAuthentication","throwError","argument","authorization","base64Encode","reData","RegExp","dataMatch","match","base64Decode","result","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","reject","makeError","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","parseInt","Math","random","pow","serverError","throttleRetry","race","_fetchData","JSON","parse","poll","floor","ceiling","interval","done","Error","retryLimit","check","then","oncePoll","once","onceBlock","version","Formatter","this","formats","getDefaultFormats","address","bind","bigNumber","blockTag","data","hash","hex","number","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","BigNumber","toNumber","strict","isHexString","getAddress","hexDataSlice","AddressZero","getContractAddress","hexValue","hexDataLength","hexZeroPad","format","author","_difficulty","_block","gas","isZero","input","networkId","replace","parseTransaction","byzantium","Array","isArray","map","object","checkKey","checkValue","nullValue","replaceValue","array","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","log","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","sort","join","getEventTag","eventName","ForkEvent","warn","getTime","Date","PollableEvents","Event","tag","listener","defineReadOnly","_lastBlockNumber","_inflight","comps","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","Base58","concat","sha256","matcherIpfs","matchers","_parseString","start","_parseBytes","offset","getIpfsLink","link","numPad","padded","set","bytesPad","ceil","encodeBytes","datas","byteCount","i","hexConcat","Resolver","resolvedAddress","formatter","_supportsEip2544","call","eq","catch","code","selector","parameters","tx","ccipReadEnabled","namehash","parseBytes","supportsWildcard","dnsEncode","_fetch","coinType","hexBytes","coinInfo","operation","bytes","words","bech32","unshift","HashZero","callAddress","_fetchBytes","_getAddress","linkage","content","getText","avatar","scheme","_resolvedAddress","owner","addr","tokenId","tokenOwner","balance","toString","metadataUrl","metadata","stringify","imageUrl","image","ipfs","ipns","swarm","skynet","urlSafe","a","keyBytes","defaultFormatter","nextPollId","BaseProvider","_events","_emitted","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","event","calldata","urls","sender","errorMessages","errorMessage","message","m","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","resolveProperties","perform","networkError","_setFastBlockNumber","pollId","runners","_getInternalBlockNumber","pollingInterval","abs","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","all","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","now","getBlockNumber","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","__awaiter","getTransactionCount","getTransaction","mined","getBlockWithTransactions","ti","waitForTransaction","reason","cancelled","replacement","_wrapTransaction","unref","addressOrName","_getBlockTag","params","position","p","expectedHash","returnedHash","wait","confirms","signedTransaction","t","hexTx","values","redirects","txSender","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipReadFetch","ccipResult","_call","_getTransactionRequest","resolved","resolveName","blockHashOrBlockTag","includeTransactions","blockWithTxs","_getBlock","_getFilter","currentName","_getResolver","resolver","addrData","getResolver","node","resolverAddr","nameOrAddress","resolverAddress","getAvatar","e","pollable","_startEvent","_addEventListener","args","stopped","eventTag","apply","_stopEvent","removeAllListeners","found","Provider","errorGas","spelunk","requireData","checkError","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","UncheckedJsonRpcSigner","_address","_index","send","accounts","fromAddress","estimate","estimateGas","constructor","hexlifyTransaction","sendUncheckedTransaction","domain","types","_TypedDataEncoder","populated","Signer","allowedTransactionKeys","networkOrReady","freeze","_nextId","_eventLoopCache","_cache","_uncachedDetectNetwork","getSigner","connectUnchecked","id","jsonrpc","action","deepCopy","getFeeData","feeData","prepareRequest","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","listenerCount","allowExtra","allowed","checkProperties","WS","WebSocket","NextId","WebSocketProvider","_wsReady","websocket","onopen","_requests","onmessage","messageEvent","callback","sub","_subs","subscription","fauxPoll","_websocket","_detectNetwork","rid","param","subIdPromise","_subIds","subId","_subscribe","emitReceipt","readyState","onerror","close","StaticJsonRpcProvider","_super","UrlJsonRpcProvider","apiKey","checkAbstract","defaultApiKey","AlchemyWebSocketProvider","host","arguments","getHost","projectSecret","getTransactionPostData","maxFeePerGs","storageKeys","getJsonResult","checkLogTag","getBaseUrl","module","query","reduce","accum","baseUrl","apikey","post","getPostUrl","getPostData","procFunc","payloadStr","txhash","postData","topic0","blocks","getBlock","parseFloat","ethusd","endBlock","startblock","endblock","item","timeStamp","checkNetworks","median","maxDelta","middle","b","serialize","nextRid","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","getProcessFunc","normalize","configs","c","_highestBlockNumber","tally","count","normalizedTally","waitForSync","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","providerConfigs","configOrProvider","index","stallTimeout","priority","total","sendTransaction","results","shuffled","first","t0","inflightWeight","backend","waiting","errors","errorCode","props","IpcProvider","defaultProjectId","InfuraWebSocketProvider","projectId","apiKeyObj","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","n","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider"],"sourceRoot":""}