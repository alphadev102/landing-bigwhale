{"version":3,"file":"static/js/9979.e8d09ab9.chunk.js","mappings":"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","sources":["../../../../src/communication/index.ts","../../../../src/communication/messageFormatter.ts","../../../../src/communication/methods.ts","../../../../src/communication/utils.ts","../../../../src/eth/constants.ts","../../../../src/eth/index.ts","../../../src/index.ts","../../../../src/safe/index.ts","../../../../src/safe/signatures.ts","../../../src/sdk.ts","../../../../src/txs/index.ts","../../../../src/types/gateway.ts","../../../../src/types/index.ts","../../../../src/types/messaging.ts","../../../src/utils.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/contracts/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bignumber/src.ts/fixednumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/message.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/random/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/node_modules/@ethersproject/random/src.ts/browser-random.ts","../node_modules/@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts","../node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/@ethersproject/random/src.ts/browser-random.ts","../node_modules/@ethersproject/random/src.ts/_version.ts","../node_modules/@ethersproject/json-wallets/src.ts/utils.ts","../node_modules/@ethersproject/json-wallets/src.ts/_version.ts","../node_modules/@ethersproject/json-wallets/src.ts/keystore.ts","../node_modules/@ethersproject/json-wallets/src.ts/crowdsale.ts","../node_modules/@ethersproject/json-wallets/src.ts/inspect.ts","../node_modules/@ethersproject/json-wallets/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wallet/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/constants/src.ts/strings.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/base64/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bytes/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/idna.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/src.ts/message.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/solidity/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/random/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/random/src.ts/browser-random.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/src.ts/idna.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/src.ts/bytes32.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/node_modules/@ethersproject/bignumber/src.ts/fixednumber.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/units/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/src.ts/_version.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/src.ts/ethers.ts","../node_modules/@gnosis.pm/safe-apps-sdk/node_modules/ethers/src.ts/index.ts","../\"@gnosis.pm/safe-react-gateway-sdk\"/webpack/universalModuleDefinition","../\"@gnosis.pm/safe-react-gateway-sdk\"/node_modules/cross-fetch/dist/browser-ponyfill.js","../\"@gnosis.pm/safe-react-gateway-sdk\"/webpack/bootstrap","../\"@gnosis.pm/safe-react-gateway-sdk\"/webpack/runtime/compat get default export","../\"@gnosis.pm/safe-react-gateway-sdk\"/webpack/runtime/define property getters","../\"@gnosis.pm/safe-react-gateway-sdk\"/webpack/runtime/hasOwnProperty shorthand","../\"@gnosis.pm/safe-react-gateway-sdk\"/webpack/runtime/make namespace object","../\"@gnosis.pm/safe-react-gateway-sdk\"/src/types/safe-apps.ts","../\"@gnosis.pm/safe-react-gateway-sdk\"/src/types/transactions.ts","../\"@gnosis.pm/safe-react-gateway-sdk\"/src/types/chains.ts","../\"@gnosis.pm/safe-react-gateway-sdk\"/src/types/common.ts","../\"@gnosis.pm/safe-react-gateway-sdk\"/src/utils.ts","../\"@gnosis.pm/safe-react-gateway-sdk\"/src/endpoint.ts","../\"@gnosis.pm/safe-react-gateway-sdk\"/src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"abi/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"rlp/5.7.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment | string, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            }\n\n            if (param.type.match(/^u?int/)) {\n                value = BigNumber.from(value).toHexString();\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = (<EventFragment>eventFragment).inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    lastBaseFeePerGas: null | BigNumber;\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            lastBaseFeePerGas = block.baseFeePerGas;\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","export const version = \"abstract-provider/5.7.0\";\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.7.0\";\n","export const version = \"transactions/5.7.0\";\n","export const version = \"contracts/5.6.2\";\n","\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") { fraction = \"0\"; }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.2\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    lastBaseFeePerGas: null | BigNumber;\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            lastBaseFeePerGas = block.baseFeePerGas;\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","export const version = \"abstract-provider/5.7.0\";\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.7.0\";\n","export const version = \"strings/5.7.0\";\n","import { Bytes, concat } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport const messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n\nexport function hashMessage(message: Bytes | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(messagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}\n\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","export const version = \"hash/5.7.0\";\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","export const version = \"sha2/5.7.0\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.7.0\";\n","export const version = \"rlp/5.7.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","export const version = \"transactions/5.7.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"wordlists/5.7.0\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n","export const version = \"random/5.7.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Debugging line for testing browser lib in node\n//const window = { crypto: { getRandomValues: () => { } } };\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\n\nlet crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\nif (!crypto || !crypto.getRandomValues) {\n\n    logger.warn(\"WARNING: Missing strong random number source\");\n\n    crypto = {\n        getRandomValues: function(buffer: Uint8Array): Uint8Array {\n            return logger.throwError(\"no secure random source avaialble\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"crypto.getRandomValues\"\n            });\n        }\n    };\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n        logger.throwArgumentError(\"invalid length\", \"length\", length);\n    }\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return arrayify(result);\n};\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","export const version = \"wordlists/5.7.0\";\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.7.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Debugging line for testing browser lib in node\n//const window = { crypto: { getRandomValues: () => { } } };\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\n\nlet crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\nif (!crypto || !crypto.getRandomValues) {\n\n    logger.warn(\"WARNING: Missing strong random number source\");\n\n    crypto = {\n        getRandomValues: function(buffer: Uint8Array): Uint8Array {\n            return logger.throwError(\"no secure random source avaialble\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"crypto.getRandomValues\"\n            });\n        }\n    };\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n        logger.throwArgumentError(\"invalid length\", \"length\", length);\n    }\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return arrayify(result);\n};\n","export const version = \"random/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, Bytes, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from '@ethersproject/strings';\n\nexport function looseArrayify(hexString: string): Uint8Array {\n    if (typeof(hexString) === 'string' && hexString.substring(0, 2) !== '0x') {\n        hexString = '0x' + hexString;\n    }\n    return arrayify(hexString);\n}\n\nexport function zpad(value: String | number, length: number): String {\n    value = String(value);\n    while (value.length < length) { value = '0' + value; }\n    return value;\n}\n\nexport function getPassword(password: Bytes | string): Uint8Array {\n    if (typeof(password) === 'string') {\n        return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);\n    }\n    return arrayify(password);\n}\n\nexport function searchPath(object: any, path: string): string {\n    let currentChild = object;\n\n    const comps = path.toLowerCase().split('/');\n    for (let i = 0; i < comps.length; i++) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comps[i]) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        // Didn't find one. :'(\n        if (matchingChild === null) {\n            return null;\n        }\n\n        // Now check this child...\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = arrayify(randomBytes);\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n\n","export const version = \"json-wallets/5.6.1\";\n","\"use strict\";\n\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, Mnemonic, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\n\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Exported Types\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\n}\n\nexport interface _KeystoreAccount {\n    address: string;\n    privateKey: string;\n    mnemonic?: Mnemonic;\n\n    _isKeystoreAccount: boolean;\n}\n\nexport class KeystoreAccount extends Description<_KeystoreAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: Mnemonic;\n\n    readonly _isKeystoreAccount: boolean;\n\n    isKeystoreAccount(value: any): value is KeystoreAccount {\n        return !!(value && value._isKeystoreAccount);\n    }\n}\n\nexport type ProgressCallback = (percent: number) => void;\n\nexport type EncryptOptions = {\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}\n\nfunction _decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): Uint8Array {\n    const cipher = searchPath(data, \"crypto/cipher\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"))\n        const counter = new aes.Counter(iv);\n\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n\n        return arrayify(aesCtr.decrypt(ciphertext));\n    }\n\n    return null;\n}\n\nfunction _getAccount(data: any, key: Uint8Array): KeystoreAccount {\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n        throw new Error(\"invalid password\");\n    }\n\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n    if (!privateKey) {\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"decrypt\"\n        });\n    }\n\n    const mnemonicKey = key.slice(32, 64);\n\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (check.substring(0, 2) !== \"0x\") { check = \"0x\" + check; }\n\n        if (getAddress(check) !== address) {\n            throw new Error(\"address mismatch\");\n        }\n    }\n\n    const account: _KeystoreAccount = {\n        _isKeystoreAccount: true,\n        address: address,\n        privateKey: hexlify(privateKey)\n    };\n\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n        try {\n            const mnemonic = entropyToMnemonic(entropy, locale);\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n\n            account.mnemonic = node.mnemonic;\n\n        } catch (error) {\n            // If we don't have the locale wordlist installed to\n            // read this mnemonic, just bail and don't set the\n            // mnemonic\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n                throw error;\n            }\n        }\n    }\n\n    return new KeystoreAccount(account);\n}\n\ntype ScryptFunc<T> = (pw: Uint8Array, salt: Uint8Array, n: number, r: number, p: number, dkLen: number, callback?: ProgressCallback) => T;\ntype Pbkdf2Func<T> = (pw: Uint8Array, salt: Uint8Array, c: number, dkLen: number, prfFunc: string) => T;\n\nfunction pbkdf2Sync(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Uint8Array {\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Promise<Uint8Array> {\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey<T>(data: any, password: Bytes | string, pbkdf2Func: Pbkdf2Func<T>, scryptFunc: ScryptFunc<T>, progressCallback?: ProgressCallback): T {\n    const passwordBytes = getPassword(password);\n\n    const kdf = searchPath(data, \"crypto/kdf\");\n\n    if (kdf && typeof(kdf) === \"string\") {\n        const throwError = function(name: string, value: any): never {\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n        }\n\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n\n            // Check for all required parameters\n            if (!N || !r || !p) { throwError(\"kdf\", kdf); }\n\n            // Make sure N is a power of 2\n            if ((N & (N - 1)) !== 0) { throwError(\"N\", N); }\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n\n            let prfFunc: string = null;\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\n            if (prf === \"hmac-sha256\") {\n                prfFunc = \"sha256\";\n            } else if (prf === \"hmac-sha512\") {\n                prfFunc = \"sha512\";\n            } else {\n                throwError(\"prf\", prf);\n            }\n\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n        }\n    }\n\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\n\nexport function decryptSync(json: string, password: Bytes | string): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n    return _getAccount(data, key);\n}\n\nexport async function decrypt(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const key = await _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n}\n\n\nexport function encrypt(account: ExternallyOwnedAccount, password: Bytes | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string> {\n\n    try {\n        // Check the address matches the private key\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n            throw new Error(\"address/privateKey mismatch\");\n        }\n\n        // Check the mnemonic (if any) matches the private key\n        if (hasMnemonic(account)) {\n            const mnemonic = account.mnemonic;\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n        }\n\n    } catch (e) {\n        return Promise.reject(e);\n    }\n\n    // The options are optional, so adjust the call as needed\n    if (typeof(options) === \"function\" && !progressCallback) {\n        progressCallback = options;\n        options = {};\n    }\n    if (!options) { options = {}; }\n\n    const privateKey: Uint8Array = arrayify(account.privateKey);\n    const passwordBytes = getPassword(password);\n\n    let entropy: Uint8Array = null\n    let path: string = null;\n    let locale: string = null;\n    if (hasMnemonic(account)) {\n        const srcMnemonic = account.mnemonic;\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n        path = srcMnemonic.path || defaultPath;\n        locale = srcMnemonic.locale || \"en\";\n    }\n\n    let client = options.client;\n    if (!client) { client = \"ethers.js\"; }\n\n    // Check/generate the salt\n    let salt: Uint8Array = null;\n    if (options.salt) {\n        salt = arrayify(options.salt);\n    } else {\n        salt = randomBytes(32);;\n    }\n\n    // Override initialization vector\n    let iv: Uint8Array = null;\n    if (options.iv) {\n        iv = arrayify(options.iv);\n        if (iv.length !== 16) { throw new Error(\"invalid iv\"); }\n    } else {\n       iv = randomBytes(16);\n    }\n\n    // Override the uuid\n    let uuidRandom: Uint8Array = null;\n    if (options.uuid) {\n        uuidRandom = arrayify(options.uuid);\n        if (uuidRandom.length !== 16) { throw new Error(\"invalid uuid\"); }\n    } else {\n        uuidRandom = randomBytes(16);\n    }\n\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) { N = options.scrypt.N; }\n        if (options.scrypt.r) { r = options.scrypt.r; }\n        if (options.scrypt.p) { p = options.scrypt.p; }\n    }\n\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\n        key = arrayify(key);\n\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\n        const derivedKey = key.slice(0, 16);\n        const macPrefix = key.slice(16, 32);\n\n        // This will be used to encrypt the mnemonic phrase (if any)\n        const mnemonicKey = key.slice(32, 64);\n\n        // Encrypt the private key\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n\n        // Compute the message authentication code, used to check the password\n        const mac = keccak256(concat([macPrefix, ciphertext]))\n\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n        const data: { [key: string]: any } = {\n            address: account.address.substring(2).toLowerCase(),\n            id: uuidV4(uuidRandom),\n            version: 3,\n            Crypto: {\n                cipher: \"aes-128-ctr\",\n                cipherparams: {\n                    iv: hexlify(iv).substring(2),\n                },\n                ciphertext: hexlify(ciphertext).substring(2),\n                kdf: \"scrypt\",\n                kdfparams: {\n                    salt: hexlify(salt).substring(2),\n                    n: N,\n                    dklen: 32,\n                    p: p,\n                    r: r\n                },\n                mac: mac.substring(2)\n            }\n        };\n\n        // If we have a mnemonic, encrypt it into the JSON wallet\n        if (entropy) {\n            const mnemonicIv = randomBytes(16);\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n            const now = new Date();\n            const timestamp = (now.getUTCFullYear() + \"-\" +\n                               zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                               zpad(now.getUTCDate(), 2) + \"T\" +\n                               zpad(now.getUTCHours(), 2) + \"-\" +\n                               zpad(now.getUTCMinutes(), 2) + \"-\" +\n                               zpad(now.getUTCSeconds(), 2) + \".0Z\"\n                              );\n            data[\"x-ethers\"] = {\n                client: client,\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n                path: path,\n                locale: locale,\n                version: \"0.1\"\n            };\n        }\n\n        return JSON.stringify(data);\n    });\n}\n","\"use strict\";\n\nimport aes from \"aes-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Description } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\n\nexport interface _CrowdsaleAccount {\n    address: string;\n    privateKey: string;\n\n    _isCrowdsaleAccount: boolean;\n}\n\nexport class CrowdsaleAccount extends Description<_CrowdsaleAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: string;\n    readonly path?: string;\n\n    readonly _isCrowdsaleAccount: boolean;\n\n    isCrowdsaleAccount(value: any): value is CrowdsaleAccount {\n        return !!(value && value._isCrowdsaleAccount);\n    }\n}\n\n// See: https://github.com/ethereum/pyethsaletool\nexport function decrypt(json: string, password: Bytes | string): ExternallyOwnedAccount {\n    const data = JSON.parse(json);\n\n    password = getPassword(password);\n\n    // Ethereum Address\n    const ethaddr = getAddress(searchPath(data, \"ethaddr\"));\n\n    // Encrypted Seed\n    const encseed = looseArrayify(searchPath(data, \"encseed\"));\n    if (!encseed || (encseed.length % 16) !== 0) {\n        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n    }\n\n    const key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n\n    // Decrypt the seed\n    const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n    const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));\n\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n\n    const seedHexBytes = toUtf8Bytes(seedHex);\n\n    const privateKey = keccak256(seedHexBytes);\n\n    return new CrowdsaleAccount ({\n        _isCrowdsaleAccount: true,\n        address: ethaddr,\n        privateKey: privateKey\n    });\n}\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\n\n\nexport function isCrowdsaleWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    return (data.encseed && data.ethaddr);\n}\n\nexport function isKeystoreWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n        return false;\n    }\n\n    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n    return true;\n}\n\n//export function isJsonWallet(json: string): boolean {\n//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n//}\n\nexport function getJsonWalletAddress(json: string): string {\n    if (isCrowdsaleWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).ethaddr);\n        } catch (error) { return null; }\n    }\n\n    if (isKeystoreWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).address);\n        } catch (error) { return null; }\n    }\n\n    return null;\n}\n\n","\"use strict\";\n\nimport { Bytes } from \"@ethersproject/bytes\";\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\n\nimport { decrypt as decryptCrowdsale } from \"./crowdsale\";\nimport { getJsonWalletAddress, isCrowdsaleWallet, isKeystoreWallet } from \"./inspect\";\nimport { decrypt as decryptKeystore, decryptSync as decryptKeystoreSync, encrypt as encryptKeystore, EncryptOptions, ProgressCallback } from \"./keystore\";\n\nfunction decryptJsonWallet(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<ExternallyOwnedAccount> {\n    if (isCrowdsaleWallet(json)) {\n        if (progressCallback) { progressCallback(0); }\n        const account = decryptCrowdsale(json, password)\n        if (progressCallback) { progressCallback(1); }\n        return Promise.resolve(account);\n    }\n\n    if (isKeystoreWallet(json)) {\n        return decryptKeystore(json, password, progressCallback);\n    }\n\n    return Promise.reject(new Error(\"invalid JSON wallet\"));\n}\n\nfunction decryptJsonWalletSync(json: string, password: Bytes | string): ExternallyOwnedAccount {\n    if (isCrowdsaleWallet(json)) {\n        return decryptCrowdsale(json, password)\n    }\n\n    if (isKeystoreWallet(json)) {\n        return decryptKeystoreSync(json, password);\n    }\n\n    throw new Error(\"invalid JSON wallet\");\n}\n\nexport {\n    decryptCrowdsale,\n\n    decryptKeystore,\n    decryptKeystoreSync,\n    encryptKeystore,\n\n    isCrowdsaleWallet,\n    isKeystoreWallet,\n    getJsonWalletAddress,\n\n    decryptJsonWallet,\n    decryptJsonWalletSync,\n\n    ProgressCallback,\n    EncryptOptions,\n};\n","export const version = \"wallet/5.6.2\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\nimport { Wordlist } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\n\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\n\n    readonly address: string;\n    readonly provider: Provider;\n\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\n    // leaking the private key in console.log; still, be careful! :)\n    readonly _signingKey: () => SigningKey;\n    readonly _mnemonic: () => Mnemonic;\n\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\n        super();\n\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => (\n                    {\n                        phrase: srcMnemonic.phrase,\n                        path: srcMnemonic.path || defaultPath,\n                        locale: srcMnemonic.locale || \"en\"\n                    }\n                ));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            } else {\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            }\n\n\n        } else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\n\n            } else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof(privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\n    get privateKey(): string { return this._signingKey().privateKey; }\n    get publicKey(): string { return this._signingKey().publicKey; }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    connect(provider: Provider): Wallet {\n        return new Wallet(this, provider);\n    }\n\n    signTransaction(transaction: TransactionRequest): Promise<string> {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\n            return serialize(<UnsignedTransaction>tx, signature);\n        });\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            if (this.provider == null) {\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"resolveName\",\n                    value: name\n                });\n            }\n            return this.provider.resolveName(name);\n        });\n\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    }\n\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\n        if (typeof(options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n\n        if (!options) { options = {}; }\n\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n\n\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options?: any): Wallet {\n        let entropy: Uint8Array = randomBytes(16);\n\n        if (!options) { options = { }; }\n\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\n        }\n\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\n        if (!path) { path = defaultPath; }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\n\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\n    return recoverAddress(hashMessage(message), signature);\n}\n\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","// NFKC (composed)             // (decomposed)\nexport const EtherSymbol = \"\\u039e\";  // \"\\uD835\\uDF63\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","export const version = \"wordlists/5.6.1\";\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"abi/5.6.4\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            }\n\n            if (param.type.match(/^u?int/)) {\n                value = BigNumber.from(value).toHexString();\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"rlp/5.7.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","export const version = \"address/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.6.1\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\n\ntype Ranged = {\n    l: number,          // Lo value\n    h: number,          // High value (less the lo)\n    d?: number,         // Delta/stride (default: 1)\n    s?: number,         // Shift (default: 1)\n    e?: Array<number>   // Exceptions to skip\n};\n\ntype Table = { [ src: number ]: Array<number> };\n\nfunction bytes2(data: string): Array<number> {\n    if ((data.length % 4) !== 0) { throw new Error(\"bad data\"); }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\n\nfunction createTable(data: string, func?: (value: string) => Array<number>): Table {\n    if (!func) {\n        func = function(value: string) { return [ parseInt(value, 16) ]; }\n    }\n\n    let lo = 0;\n\n    let result: Table = { };\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n\n    return result;\n}\n\nfunction createRangeTable(data: string): Array<Ranged> {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\n\nfunction matchMap(value: number, ranges: Array<Ranged>): Ranged {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) { continue; }\n            return range;\n        }\n    }\n    return null;\n}\n\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\n\nconst Table_B_2_ranges: Array<Ranged> = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [ 23 ], l: 127 },\n    { h: 54, s: 1, e: [ 48 ], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [ 2, 6, 8 ], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [ 18, 24, 66 ], l: 19, d: 2 },\n    { h: 26, s: 32, e: [ 17 ], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [ 38 ], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [ 1, 4, 5, 7, 8, 11, 12, 17 ], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [ 2, 7, 8, 17 ], l: 52 },\n    { h: 24, s: -120023, e: [ 2, 7, 13, 15, 16, 17 ], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [ 17 ], l: 56 },\n    { h: 24, s: -119601, e: [ 17 ], l: 58 },\n    { h: 24, s: -119659, e: [ 17 ], l: 58 },\n    { h: 24, s: -119717, e: [ 17 ], l: 58 },\n    { h: 24, s: -119775, e: [ 17 ], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\n\nfunction flatten(values: Array<Array<number>>): Array<number> {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, [ ]);\n}\n\nexport function _nameprepTableA1(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\n\nexport function _nameprepTableB2(codepoint: number): Array<number> {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) { return [ codepoint + range.s ]; }\n\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) { return codes; }\n\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) { return [ codepoint + shift[0] ]; }\n\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) { return complex; }\n\n    return null;\n}\n\nexport function _nameprepTableC(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\n\nexport function nameprep(value: string): string {\n\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) { return value.toLowerCase(); }\n\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) { return [ ]; }\n        if (code >= 0xfe00 && code <= 0xfe0f) { return [ ]; }\n\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) { return codesTableB2; }\n\n        // No Substitution\n        return [ code ];\n    }));\n\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n\n    // IDNA extras\n    let name = _toUtf8String(codes);\n\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n\n    return name;\n}\n\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"hash/5.6.1\";\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\nexport function isValidName(name: string): boolean {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\")\n            }\n        }\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let current = name;\n    let result: string | Uint8Array = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n\n        current = partition[2] || \"\";\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(name.split(\".\").map((comp) => {\n        // We jam in an _ prefix to fill in with the length later\n        // Note: Nameprep throws if the component is over 63 bytes\n        const bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n","import { Bytes, concat } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport const messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n\nexport function hashMessage(message: Bytes | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(messagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}\n\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","export const version = \"sha2/5.7.0\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"transactions/5.7.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"wordlists/5.7.0\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.6.2\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"logger/5.6.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","export const version = \"sha2/5.6.1\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.7.0\";\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","export const version = \"solidity/5.6.1\";\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\n    switch(type) {\n        case \"address\":\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return arrayify(value);\n        case \"bool\":\n            value = (value ? \"0x01\": \"0x00\");\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n    }\n\n    let match =  type.match(regexNumber);\n    if (match) {\n        //let signed = (match[1] === \"int\")\n        let size = parseInt(match[2] || \"256\")\n\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n            logger.throwArgumentError(\"invalid number type\", \"type\", type)\n        }\n\n        if (isArray) { size = 256; }\n\n        value = BigNumber.from(value).toTwos(size);\n\n        return zeroPad(value, size / 8);\n    }\n\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n\n        if (String(size) !== match[1] || size === 0 || size > 32) {\n            logger.throwArgumentError(\"invalid bytes type\", \"type\", type)\n        }\n        if (arrayify(value).byteLength !== size) {\n            logger.throwArgumentError(`invalid value for ${ type }`, \"value\", value)\n        }\n        if (isArray) { return arrayify((value + Zeros).substring(0, 66)); }\n        return value;\n    }\n\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        if (count != value.length) {\n            logger.throwArgumentError(`invalid array length for ${ type }`, \"value\", value)\n        }\n        const result: Array<Uint8Array> = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return concat(result);\n    }\n\n    return logger.throwArgumentError(\"invalid type\", \"type\", type)\n}\n\n// @TODO: Array Enum\n\nexport function pack(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    if (types.length != values.length) {\n        logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values)\n    }\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n\nexport function keccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashKeccak256(pack(types, values));\n}\n\nexport function sha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashSha256(pack(types, values));\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"random/5.6.1\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Debugging line for testing browser lib in node\n//const window = { crypto: { getRandomValues: () => { } } };\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\n\nlet crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\nif (!crypto || !crypto.getRandomValues) {\n\n    logger.warn(\"WARNING: Missing strong random number source\");\n\n    crypto = {\n        getRandomValues: function(buffer: Uint8Array): Uint8Array {\n            return logger.throwError(\"no secure random source avaialble\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"crypto.getRandomValues\"\n            });\n        }\n    };\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n        logger.throwArgumentError(\"invalid length\", \"length\", length);\n    }\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return arrayify(result);\n};\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"properties/5.6.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"rlp/5.6.1\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.6.2\";\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\n\ntype Ranged = {\n    l: number,          // Lo value\n    h: number,          // High value (less the lo)\n    d?: number,         // Delta/stride (default: 1)\n    s?: number,         // Shift (default: 1)\n    e?: Array<number>   // Exceptions to skip\n};\n\ntype Table = { [ src: number ]: Array<number> };\n\nfunction bytes2(data: string): Array<number> {\n    if ((data.length % 4) !== 0) { throw new Error(\"bad data\"); }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\n\nfunction createTable(data: string, func?: (value: string) => Array<number>): Table {\n    if (!func) {\n        func = function(value: string) { return [ parseInt(value, 16) ]; }\n    }\n\n    let lo = 0;\n\n    let result: Table = { };\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n\n    return result;\n}\n\nfunction createRangeTable(data: string): Array<Ranged> {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\n\nfunction matchMap(value: number, ranges: Array<Ranged>): Ranged {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) { continue; }\n            return range;\n        }\n    }\n    return null;\n}\n\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\n\nconst Table_B_2_ranges: Array<Ranged> = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [ 23 ], l: 127 },\n    { h: 54, s: 1, e: [ 48 ], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [ 2, 6, 8 ], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [ 18, 24, 66 ], l: 19, d: 2 },\n    { h: 26, s: 32, e: [ 17 ], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [ 38 ], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [ 1, 4, 5, 7, 8, 11, 12, 17 ], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [ 2, 7, 8, 17 ], l: 52 },\n    { h: 24, s: -120023, e: [ 2, 7, 13, 15, 16, 17 ], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [ 17 ], l: 56 },\n    { h: 24, s: -119601, e: [ 17 ], l: 58 },\n    { h: 24, s: -119659, e: [ 17 ], l: 58 },\n    { h: 24, s: -119717, e: [ 17 ], l: 58 },\n    { h: 24, s: -119775, e: [ 17 ], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\n\nfunction flatten(values: Array<Array<number>>): Array<number> {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, [ ]);\n}\n\nexport function _nameprepTableA1(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\n\nexport function _nameprepTableB2(codepoint: number): Array<number> {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) { return [ codepoint + range.s ]; }\n\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) { return codes; }\n\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) { return [ codepoint + shift[0] ]; }\n\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) { return complex; }\n\n    return null;\n}\n\nexport function _nameprepTableC(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\n\nexport function nameprep(value: string): string {\n\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) { return value.toLowerCase(); }\n\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) { return [ ]; }\n        if (code >= 0xfe00 && code <= 0xfe0f) { return [ ]; }\n\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) { return codesTableB2; }\n\n        // No Substitution\n        return [ code ];\n    }));\n\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n\n    // IDNA extras\n    let name = _toUtf8String(codes);\n\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n\n    // IDNA: 4.2.4\n    if (name.length > 63) { throw new Error(\"too long\"); }\n\n\n\n    return name;\n}\n\n","\"use strict\";\n\nimport { HashZero } from \"@ethersproject/constants\";\nimport { arrayify, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\n\nimport { toUtf8Bytes, toUtf8String } from \"./utf8\";\n\n\nexport function formatBytes32String(text: string): string {\n\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n\n    // Check we have room for null-termination\n    if (bytes.length > 31) { throw new Error(\"bytes32 string must be less than 32 bytes\"); }\n\n    // Zero-pad (implicitly null-terminates)\n    return hexlify(concat([ bytes, HashZero ]).slice(0, 32));\n}\n\nexport function parseBytes32String(bytes: BytesLike): string {\n    const data = arrayify(bytes);\n\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) { throw new Error(\"invalid bytes32 - not 32 bytes long\"); }\n    if (data[31] !== 0) { throw new Error(\"invalid bytes32 string - no null terminator\"); }\n\n    // Find the null termination\n    let length = 31;\n    while (data[length - 1] === 0) { length--; }\n\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\n\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","export const version = \"rlp/5.7.0\";\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.7.0\";\n","export const version = \"transactions/5.6.2\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") { fraction = \"0\"; }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n\n\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nexport function commify(value: string | number): string {\n    const comps = String(value).split(\".\");\n\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") { whole = whole.substring(1); }\n    if (whole === \"\") { whole = \"0\"; }\n\n    let suffix = \"\";\n    if (comps.length === 2) { suffix = \".\" + (comps[1] || \"0\"); }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        } else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n\n    return negative + formatted.join(\",\") + suffix;\n}\n\nexport function formatUnits(value: BigNumberish, unitName?: string | BigNumberish): string {\n    if (typeof(unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) { unitName = 3 * index; }\n    }\n    return formatFixed(value, (unitName != null) ? unitName: 18);\n}\n\nexport function parseUnits(value: string, unitName?: BigNumberish): BigNumber {\n    if (typeof(value) !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof(unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) { unitName = 3 * index; }\n    }\n    return parseFixed(value, (unitName != null) ? unitName: 18);\n}\n\nexport function formatEther(wei: BigNumberish): string {\n    return formatUnits(wei, 18);\n}\n\nexport function parseEther(ether: string): BigNumber {\n    return parseUnits(ether, 18);\n}\n\n","export const version = \"units/5.6.1\";\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","export const version = \"strings/5.7.0\";\n","export const version = \"web/5.6.1\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n    }\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"ethers/5.6.9\";\n","\"use strict\";\n\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\n\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\n\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\n\nimport * as constants from \"@ethersproject/constants\";\n\nimport * as providers from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\n\nimport { Wordlist, wordlists} from \"@ethersproject/wordlists\";\n\nimport * as utils from \"./utils\";\n\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\n\n////////////////////////\n// Types\n\nimport { BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike, Signature } from \"@ethersproject/bytes\";\nimport { Transaction, UnsignedTransaction } from \"@ethersproject/transactions\";\n\n\n////////////////////////\n// Compile-Time Constants\n\n// This is generated by \"npm run dist\"\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\n////////////////////////\n// Types\n\nimport {\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface\n} from \"@ethersproject/contracts\";\n\n\n////////////////////////\n// Exports\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n};\n\n","\"use strict\";\n\n// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\n\nimport * as ethers from \"./ethers\";\n\ntry {\n    const anyGlobal = (window as any);\n\n    if (anyGlobal._ethers == null) {\n        anyGlobal._ethers = ethers;\n    }\n} catch (error) { }\n\nexport { ethers };\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n} from \"./ethers\";\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"\\\"@gnosis.pm/safe-react-gateway-sdk\\\"\"] = factory();\n\telse\n\t\troot[\"\\\"@gnosis.pm/safe-react-gateway-sdk\\\"\"] = factory();\n})(this, function() {\nreturn ","var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export enum SafeAppAccessPolicyTypes {\n  NoRestrictions = 'NO_RESTRICTIONS',\n  DomainAllowlist = 'DOMAIN_ALLOWLIST',\n}\n\nexport type SafeAppNoRestrictionsPolicy = {\n  type: SafeAppAccessPolicyTypes.NoRestrictions\n}\n\nexport type SafeAppDomainAllowlistPolicy = {\n  type: SafeAppAccessPolicyTypes.DomainAllowlist\n  value: string[]\n}\n\nexport type SafeAppsAccessControlPolicies = SafeAppNoRestrictionsPolicy | SafeAppDomainAllowlistPolicy\n\nexport type SafeAppProvider = {\n  url: string\n  name: string\n}\n\nexport type SafeAppData = {\n  id: number\n  url: string\n  name: string\n  iconUrl: string\n  description: string\n  chainIds: string[]\n  provider?: SafeAppProvider\n  accessControl: SafeAppsAccessControlPolicies\n  tags: string[]\n}\n\nexport type SafeAppsResponse = SafeAppData[]\n","import { AddressEx, TokenInfo } from './common'\n\nexport type ParamValue = string | ParamValue[]\n\nexport enum Operation {\n  CALL = 0,\n  DELEGATE = 1,\n}\n\nexport type InternalTransaction = {\n  operation: Operation\n  to: string\n  value: string | null\n  data: string | null\n  dataDecoded: DataDecoded | null\n}\n\nexport type ValueDecodedType = InternalTransaction[]\n\nexport type Parameter = {\n  name: string\n  type: string\n  value: ParamValue\n  valueDecoded: ValueDecodedType | null\n}\n\nexport type DataDecoded = {\n  method: string\n  parameters: Parameter[] | null\n}\n\nexport enum TransactionStatus {\n  AWAITING_CONFIRMATIONS = 'AWAITING_CONFIRMATIONS',\n  AWAITING_EXECUTION = 'AWAITING_EXECUTION',\n  CANCELLED = 'CANCELLED',\n  FAILED = 'FAILED',\n  SUCCESS = 'SUCCESS',\n  PENDING = 'PENDING',\n  WILL_BE_REPLACED = 'WILL_BE_REPLACED',\n}\n\nexport enum TransferDirection {\n  INCOMING = 'INCOMING',\n  OUTGOING = 'OUTGOING',\n  UNKNOWN = 'UNKNOWN',\n}\n\nexport enum TransactionTokenType {\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  NATIVE_COIN = 'NATIVE_COIN',\n}\n\nexport type Erc20Transfer = {\n  type: TransactionTokenType.ERC20\n  tokenAddress: string\n  tokenName: string | null\n  tokenSymbol: string | null\n  logoUri: string | null\n  decimals: number | null\n  value: string\n}\n\nexport type Erc721Transfer = {\n  type: TransactionTokenType.ERC721\n  tokenAddress: string\n  tokenId: string\n  tokenName: string | null\n  tokenSymbol: string | null\n  logoUri: string | null\n}\n\nexport type NativeCoinTransfer = {\n  type: TransactionTokenType.NATIVE_COIN\n  value: string\n}\n\nexport type TransferInfo = Erc20Transfer | Erc721Transfer | NativeCoinTransfer\n\nexport interface Transfer {\n  type: 'Transfer'\n  sender: AddressEx\n  recipient: AddressEx\n  direction: TransferDirection\n  transferInfo: TransferInfo\n}\n\nexport type SetFallbackHandler = {\n  type: 'SET_FALLBACK_HANDLER'\n  handler: AddressEx\n}\n\nexport type AddOwner = {\n  type: 'ADD_OWNER'\n  owner: AddressEx\n  threshold: number\n}\n\nexport type RemoveOwner = {\n  type: 'REMOVE_OWNER'\n  owner: AddressEx\n  threshold: number\n}\n\nexport type SwapOwner = {\n  type: 'SWAP_OWNER'\n  oldOwner: AddressEx\n  newOwner: AddressEx\n}\n\nexport type ChangeThreshold = {\n  type: 'CHANGE_THRESHOLD'\n  threshold: number\n}\n\nexport type ChangeImplementation = {\n  type: 'CHANGE_IMPLEMENTATION'\n  implementation: AddressEx\n}\n\nexport type EnableModule = {\n  type: 'ENABLE_MODULE'\n  module: AddressEx\n}\n\nexport type DisableModule = {\n  type: 'DISABLE_MODULE'\n  module: AddressEx\n}\n\nexport type SetGuard = {\n  type: 'SET_GUARD'\n  guard: AddressEx\n}\n\nexport type DeleteGuard = {\n  type: 'DELETE_GUARD'\n}\n\nexport type SettingsInfo =\n  | SetFallbackHandler\n  | AddOwner\n  | RemoveOwner\n  | SwapOwner\n  | ChangeThreshold\n  | ChangeImplementation\n  | EnableModule\n  | DisableModule\n  | SetGuard\n  | DeleteGuard\n\nexport type SettingsChange = {\n  type: 'SettingsChange'\n  dataDecoded: DataDecoded\n  settingsInfo: SettingsInfo | null\n}\n\nexport interface Custom {\n  type: 'Custom'\n  to: AddressEx\n  dataSize: string\n  value: string\n  methodName: string | null\n  actionCount: number | null\n  isCancellation: boolean\n}\n\nexport type MultiSend = {\n  type: 'Custom'\n  to: AddressEx\n  dataSize: string\n  value: string\n  methodName: 'multiSend'\n  actionCount: number\n  isCancellation: boolean\n}\n\nexport type Creation = {\n  type: 'Creation'\n  creator: AddressEx\n  transactionHash: string\n  implementation: AddressEx | null\n  factory: AddressEx | null\n}\n\nexport type TransactionInfo = Transfer | SettingsChange | Custom | MultiSend | Creation\n\nexport type ModuleExecutionInfo = {\n  type: 'MODULE'\n  address: AddressEx\n}\n\nexport type MultisigExecutionInfo = {\n  type: 'MULTISIG'\n  nonce: number\n  confirmationsRequired: number\n  confirmationsSubmitted: number\n  missingSigners: AddressEx[] | null\n}\n\nexport type ExecutionInfo = ModuleExecutionInfo | MultisigExecutionInfo\n\nexport type TransactionSummary = {\n  id: string\n  timestamp: number\n  txStatus: TransactionStatus\n  txInfo: TransactionInfo\n  executionInfo?: ExecutionInfo\n  safeAppInfo?: SafeAppInfo\n}\n\nexport type Transaction = {\n  transaction: TransactionSummary\n  conflictType: 'None' | 'HasNext' | 'End'\n  type: 'TRANSACTION'\n}\n\nexport type DateLabel = {\n  timestamp: number\n  type: 'DATE_LABEL'\n}\n\n/**\n * @see https://gnosis.github.io/safe-client-gateway/docs/routes/transactions/models/summary/enum.Label.html\n */\nexport enum LabelValue {\n  Queued = 'Queued',\n  Next = 'Next',\n}\n\nexport type Label = {\n  label: LabelValue\n  type: 'LABEL'\n}\n\nexport type ConflictHeader = {\n  nonce: number\n  type: 'CONFLICT_HEADER'\n}\n\nexport type TransactionListItem = Transaction | Label | ConflictHeader\n\ntype Page<T> = {\n  next?: string\n  previous?: string\n  results: Array<T>\n}\n\nexport type TransactionListPage = Page<TransactionListItem>\n\nexport type MultisigTransactionRequest = {\n  to: string\n  value: string\n  data: string | null\n  nonce: string\n  operation: Operation\n  safeTxGas: string\n  baseGas: string\n  gasPrice: string\n  gasToken: string\n  refundReceiver: string | null\n  safeTxHash: string\n  sender: string\n  signature?: string | null\n  origin: string | null\n}\n\n/* Transaction details types */\nexport type SafeAppInfo = {\n  name: string\n  url: string\n  logoUri: string\n}\n\nexport type TransactionData = {\n  hexData: string | null\n  dataDecoded: DataDecoded | null\n  to: AddressEx\n  value: string | null\n  operation: Operation\n  addressInfoIndex: { [key: string]: AddressEx } | null\n  trustedDelegateCallTarget: boolean\n}\n\nexport type ModuleExecutionDetails = {\n  type: 'MODULE'\n  address: AddressEx\n}\n\nexport type MultisigConfirmation = {\n  signer: AddressEx\n  signature: string | null\n  submittedAt: number\n}\n\nexport type MultisigExecutionDetails = {\n  type: 'MULTISIG'\n  submittedAt: number\n  nonce: number\n  safeTxGas: string\n  baseGas: string\n  gasPrice: string\n  gasToken: string\n  refundReceiver: AddressEx\n  safeTxHash: string\n  executor: AddressEx | null\n  signers: AddressEx[]\n  confirmationsRequired: number\n  confirmations: MultisigConfirmation[]\n  rejectors: AddressEx[] | null\n  gasTokenInfo: TokenInfo | null\n}\n\nexport type DetailedExecutionInfo = ModuleExecutionDetails | MultisigExecutionDetails\n\nexport type TransactionDetails = {\n  txId: string\n  executedAt: number | null\n  txStatus: TransactionStatus\n  txInfo: TransactionInfo\n  txData: TransactionData | null\n  detailedExecutionInfo: DetailedExecutionInfo | null\n  txHash: string | null\n  safeAppInfo: SafeAppInfo | null\n}\n\n/* Transaction details types end */\n\n/* Transaction estimation types */\n\nexport type SafeTransactionEstimationRequest = {\n  to: string\n  value: string\n  data: string\n  operation: Operation\n}\n\n// CGW v2 response\nexport type SafeTransactionEstimation = {\n  currentNonce: number\n  recommendedNonce: number\n  safeTxGas: string\n}\n\n/* Transaction estimation types end */\n","export enum RPC_AUTHENTICATION {\n  API_KEY_PATH = 'API_KEY_PATH',\n  NO_AUTHENTICATION = 'NO_AUTHENTICATION',\n  UNKNOWN = 'UNKNOWN',\n}\n\nexport type RpcUri = {\n  authentication: RPC_AUTHENTICATION\n  value: string\n}\n\nexport type BlockExplorerUriTemplate = {\n  address: string\n  txHash: string\n  api: string\n}\n\nexport type NativeCurrency = {\n  name: string\n  symbol: string\n  decimals: number\n  logoUri: string\n}\n\nexport type Theme = {\n  textColor: string\n  backgroundColor: string\n}\n\nexport enum GAS_PRICE_TYPE {\n  ORACLE = 'ORACLE',\n  FIXED = 'FIXED',\n  UNKNOWN = 'UNKNOWN',\n}\n\nexport type GasPriceOracle = {\n  type: GAS_PRICE_TYPE.ORACLE\n  uri: string\n  gasParameter: string\n  gweiFactor: string\n}\n\nexport type GasPriceFixed = {\n  type: GAS_PRICE_TYPE.FIXED\n  weiValue: string\n}\n\nexport type GasPriceUnknown = {\n  type: GAS_PRICE_TYPE.UNKNOWN\n}\n\nexport type GasPrice = (GasPriceOracle | GasPriceFixed | GasPriceUnknown)[]\n\nexport enum FEATURES {\n  ERC721 = 'ERC721',\n  SAFE_APPS = 'SAFE_APPS',\n  CONTRACT_INTERACTION = 'CONTRACT_INTERACTION',\n  DOMAIN_LOOKUP = 'DOMAIN_LOOKUP',\n  SPENDING_LIMIT = 'SPENDING_LIMIT',\n  EIP1559 = 'EIP1559',\n  SAFE_TX_GAS_OPTIONAL = 'SAFE_TX_GAS_OPTIONAL',\n}\n\n// Remain agnostic as possible and reference what is returned in the CGW, i.e.\n// https://gnosis.github.io/safe-client-gateway/docs/routes/chains/models/struct.ChainInfo.html\nexport type ChainInfo = {\n  transactionService: string\n  chainId: string // Restricted by what is returned by the CGW\n  chainName: string\n  shortName: string\n  l2: boolean\n  description: string\n  rpcUri: RpcUri\n  safeAppsRpcUri: RpcUri\n  publicRpcUri: RpcUri\n  blockExplorerUriTemplate: BlockExplorerUriTemplate\n  nativeCurrency: NativeCurrency\n  theme: Theme\n  ensRegistryAddress?: string\n  gasPrice: GasPrice\n  disabledWallets: string[]\n  features: FEATURES[]\n}\n\nexport type ChainListResponse = {\n  next: string | null\n  previous: string | null\n  results: ChainInfo[]\n}\n","export type AddressEx = {\n  value: string\n  name: string | null\n  logoUri: string | null\n}\n\nexport type SafeInfo = {\n  address: AddressEx\n  chainId: string\n  nonce: number\n  threshold: number\n  owners: AddressEx[]\n  implementation: AddressEx\n  modules: AddressEx[]\n  guard: AddressEx\n  fallbackHandler: AddressEx\n  version: string\n  collectiblesTag: string\n  txQueuedTag: string\n  txHistoryTag: string\n}\n\nexport type FiatCurrencies = string[]\n\nexport type OwnedSafes = { safes: string[] }\n\nexport enum TokenType {\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  NATIVE_TOKEN = 'NATIVE_TOKEN',\n}\n\nexport type TokenInfo = {\n  type: TokenType\n  address: string\n  decimals: number\n  symbol: string\n  name: string\n  logoUri: string | null\n}\n\nexport type SafeBalanceResponse = {\n  fiatTotal: string\n  items: Array<{\n    tokenInfo: TokenInfo\n    balance: string\n    fiatBalance: string\n    fiatConversion: string\n  }>\n}\n\nexport type SafeCollectibleResponse = {\n  address: string\n  tokenName: string\n  tokenSymbol: string\n  logoUri: string\n  id: string\n  uri: string\n  name: string\n  description: string\n  imageUri: string\n  metadata: { [key: string]: string }\n}\n","import fetch from 'cross-fetch'\n\nexport type Params = Record<string, string | number | boolean | null>\n\nexport type ErrorResponse = {\n  code: number\n  message: string\n}\n\nfunction replaceParam(str: string, key: string, value: string): string {\n  return str.replace(new RegExp(`\\\\{${key}\\\\}`, 'g'), value)\n}\n\nexport function insertParams(template: string, params?: Params): string {\n  return params\n    ? Object.keys(params).reduce((result: string, key) => {\n        return replaceParam(result, key, String(params[key]))\n      }, template)\n    : template\n}\n\nexport function stringifyQuery(query?: Params): string {\n  if (!query) {\n    return ''\n  }\n\n  const searchParams = new URLSearchParams()\n  Object.keys(query).forEach((key) => {\n    if (query[key] != null) {\n      searchParams.append(key, String(query[key]))\n    }\n  })\n  const searchString = searchParams.toString()\n  return searchString ? `?${searchString}` : ''\n}\n\nexport async function fetchData<T>(url: string, body?: unknown): Promise<T> {\n  let options:\n    | {\n        method: 'POST'\n        headers: Record<string, string>\n        body: string\n      }\n    | undefined\n  if (body != null) {\n    options = {\n      method: 'POST',\n      body: typeof body === 'string' ? body : JSON.stringify(body),\n      headers: { 'Content-Type': 'application/json' },\n    }\n  }\n\n  const resp = await fetch(url, options)\n  const json = await resp.json()\n\n  if (!resp.ok) {\n    let errTxt = ''\n    try {\n      const err = json as ErrorResponse\n      errTxt = `${err.code}: ${err.message}`\n    } catch (e) {\n      errTxt = resp.statusText\n    }\n    throw new Error(errTxt)\n  }\n\n  return json\n}\n","import { fetchData, insertParams, stringifyQuery } from './utils'\nimport { paths } from './types/api'\n\ntype Primitive = string | number | boolean | null\n\ninterface Params {\n  path?: { [key: string]: Primitive }\n  query?: { [key: string]: Primitive }\n  body?: unknown\n}\n\nexport function callEndpoint<T extends keyof paths>(\n  baseUrl: string,\n  path: T,\n  parameters?: paths[T]['get']['parameters'],\n  rawUrl?: string,\n): Promise<paths[T]['get']['responses'][200]['schema']> {\n  if (rawUrl) {\n    return fetchData(rawUrl)\n  }\n\n  const params = parameters as Params\n  const pathname = insertParams(path, params?.path)\n  const search = stringifyQuery(params?.query)\n  const url = `${baseUrl}${pathname}${search}`\n\n  return fetchData(url, params?.body)\n}\n","import { callEndpoint } from './endpoint'\nimport { operations } from './types/api'\nimport { SafeTransactionEstimation, TransactionDetails, TransactionListPage } from './types/transactions'\nimport { FiatCurrencies, OwnedSafes, SafeBalanceResponse, SafeCollectibleResponse, SafeInfo } from './types/common'\nimport { ChainListResponse, ChainInfo } from './types/chains'\nimport { SafeAppsResponse } from './types/safe-apps'\nimport { MasterCopyReponse } from './types/master-copies'\nimport { DecodedDataResponse } from './types/decoded-data'\nexport * from './types/safe-apps'\nexport * from './types/transactions'\nexport * from './types/chains'\nexport * from './types/common'\nexport * from './types/master-copies'\nexport * from './types/decoded-data'\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n/**\n * Get basic information about a Safe. E.g. owners, modules, version etc\n */\nexport function getSafeInfo(baseUrl: string, chainId: string, address: string): Promise<SafeInfo> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/safes/{address}', { path: { chainId, address } })\n}\n\n/**\n * Get the total balance and all assets stored in a Safe\n */\nexport function getBalances(\n  baseUrl: string,\n  chainId: string,\n  address: string,\n  currency = 'usd',\n  query: operations['safes_balances_list']['parameters']['query'] = {},\n): Promise<SafeBalanceResponse> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/safes/{address}/balances/{currency}', {\n    path: { chainId, address, currency },\n    query,\n  })\n}\n\n/**\n * Get a list of supported fiat currencies (e.g. USD, EUR etc)\n */\nexport function getFiatCurrencies(baseUrl: string): Promise<FiatCurrencies> {\n  return callEndpoint(baseUrl, '/v1/balances/supported-fiat-codes')\n}\n\n/**\n * Get the addresses of all Safes belonging to an owner\n */\nexport function getOwnedSafes(baseUrl: string, chainId: string, address: string): Promise<OwnedSafes> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/owners/{address}/safes', { path: { chainId, address } })\n}\n\n/**\n * Get NFTs stored in a Safe\n */\nexport function getCollectibles(\n  baseUrl: string,\n  chainId: string,\n  address: string,\n  query: operations['safes_collectibles_list']['parameters']['query'] = {},\n): Promise<SafeCollectibleResponse[]> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/safes/{address}/collectibles', {\n    path: { chainId, address },\n    query,\n  })\n}\n\n/**\n * Get a list of past Safe transactions\n */\nexport function getTransactionHistory(\n  baseUrl: string,\n  chainId: string,\n  address: string,\n  pageUrl?: string,\n): Promise<TransactionListPage> {\n  return callEndpoint(\n    baseUrl,\n    '/v1/chains/{chainId}/safes/{safe_address}/transactions/history',\n    { path: { chainId, safe_address: address }, query: {} },\n    pageUrl,\n  )\n}\n\n/**\n * Get the list of pending transactions\n */\nexport function getTransactionQueue(\n  baseUrl: string,\n  chainId: string,\n  address: string,\n  pageUrl?: string,\n): Promise<TransactionListPage> {\n  return callEndpoint(\n    baseUrl,\n    '/v1/chains/{chainId}/safes/{safe_address}/transactions/queued',\n    { path: { chainId, safe_address: address }, query: {} },\n    pageUrl,\n  )\n}\n\n/**\n * Get the details of an individual transaction by its id\n */\nexport function getTransactionDetails(\n  baseUrl: string,\n  chainId: string,\n  transactionId: string,\n): Promise<TransactionDetails> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/transactions/{transactionId}', {\n    path: { chainId, transactionId },\n  })\n}\n\n/**\n * Request a gas estimate & recommmended tx nonce for a created transaction\n */\nexport function postSafeGasEstimation(\n  baseUrl: string,\n  chainId: string,\n  address: string,\n  body: operations['post_safe_gas_estimation']['parameters']['body'],\n): Promise<SafeTransactionEstimation> {\n  return callEndpoint(baseUrl, '/v2/chains/{chainId}/safes/{safe_address}/multisig-transactions/estimations', {\n    path: { chainId, safe_address: address },\n    body,\n  })\n}\n\n/**\n * Propose a new transaction for other owners to sign/execute\n */\nexport function proposeTransaction(\n  baseUrl: string,\n  chainId: string,\n  address: string,\n  body: operations['propose_transaction']['parameters']['body'],\n): Promise<TransactionDetails> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/transactions/{safe_address}/propose', {\n    path: { chainId, safe_address: address },\n    body,\n  })\n}\n\n/**\n * Returns all defined chain configs\n */\nexport function getChainsConfig(\n  baseUrl: string,\n  query?: operations['chains_list']['parameters']['query'],\n): Promise<ChainListResponse> {\n  return callEndpoint(baseUrl, '/v1/chains', {\n    query,\n  })\n}\n\n/**\n * Returns a chain config\n */\nexport function getChainConfig(baseUrl: string, chainId: string): Promise<ChainInfo> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}', {\n    path: { chainId: chainId },\n  })\n}\n\n/**\n * Returns Safe Apps List\n */\nexport function getSafeApps(\n  baseUrl: string,\n  chainId: string,\n  query: operations['safe_apps_read']['parameters']['query'] = {},\n): Promise<SafeAppsResponse> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/safe-apps', {\n    path: { chainId: chainId },\n    query,\n  })\n}\n\n/**\n * Returns list of Master Copies\n */\nexport function getMasterCopies(baseUrl: string, chainId: string): Promise<MasterCopyReponse> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/about/master-copies', {\n    path: { chainId: chainId },\n  })\n}\n\n/**\n * Returns decoded data\n */\nexport function getDecodedData(\n  baseUrl: string,\n  chainId: string,\n  encodedData: operations['data_decoder']['parameters']['body']['data'],\n): Promise<DecodedDataResponse> {\n  return callEndpoint(baseUrl, '/v1/chains/{chainId}/data-decoder', {\n    path: { chainId: chainId },\n    body: { data: encodedData },\n  })\n}\n/* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n"],"names":["PostMessageCommunicator","allowedOrigins","debugMode","Map","origin","data","emptyOrMalformed","sentFromParentEl","source","window","parent","allowedSDKVersion","version","parseInt","split","validOrigin","Array","isArray","undefined","find","regExp","test","msg","console","info","isValidMessage","logIncomingMessage","handleIncomingMessage","payload","id","cb","callbacks","get","delete","method","params","request","messageFormatter_1","makeRequest","Error","postMessage","Promise","resolve","reject","set","response","success","error","addEventListener","onParentMessage","exports","__exportStar","MessageFormatter","env","sdkVersion","Methods","dec2hex","dec","toString","padStart","len","arr","Uint8Array","crypto","getRandomValues","from","join","generateId","Date","getTime","eth_call","eth_gasPrice","eth_getLogs","eth_getBalance","eth_getCode","eth_getBlockByHash","eth_getBlockByNumber","eth_getStorageAt","eth_getTransactionByHash","eth_getTransactionReceipt","eth_getTransactionCount","eth_estimateGas","inputFormatters","defaultBlockParam","arg","returnFullTxObjectParam","blockNumberToHex","Number","isInteger","Eth","communicator","call","buildRequest","constants_1","formatters","getBalance","getCode","getStorageAt","getPastLogs","getBlockByHash","getBlockByNumber","getTransactionByHash","getTransactionReceipt","getTransactionCount","getGasPrice","getEstimateGas","transaction","args","forEach","formatter","i","send","methods_1","rpcCall","sdk_1","Object","enumerable","Safe","getChainInfo","getSafeInfo","currency","getSafeBalances","messageHash","signature","getInfo","safeInfo","encodedIsValidSignatureCall","signatures_1","encodeFunctionData","to","safeAddress","slice","toLowerCase","msgBytes","ethers_1","utils","arrayify","message","hashMessage","calculateMessageHash","isMessageHashSigned","messageHashSigned","checks","check1271Signature","bind","check1271SignatureBytes","check","EIP_1271_INTERFACE","Interface","EIP_1271_BYTES_INTERFACE","SafeAppsSDK","opts","whitelistedDomains","debug","communication_1","eth","eth_1","txs","txs_1","safe","safe_1","TXs","safeTxHash","getTxBySafeTxHash","messagePayload","signMessage","length","sendTransactions","package_json_1","_permanentCensorErrors","_censorErrors","LogLevels","warning","off","_logLevel","_globalLogger","LogLevel","ErrorCode","_normalizeError","missing","form","normalize","push","String","fromCharCode","_checkNormalize","HEX","Logger","defineProperty","this","value","writable","logLevel","level","throwArgumentError","log","apply","_log","levels","DEBUG","INFO","WARNING","code","makeError","errors","UNKNOWN_ERROR","messageDetails","keys","key","hex","JSON","stringify","reason","url","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","name","throwError","INVALID_ARGUMENT","argument","condition","UNSUPPORTED_OPERATION","operation","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","target","kind","censorship","permanent","globalLogger","warn","logger","isHexable","toHexString","addSlice","array","prototype","arguments","isBytesLike","isHexString","isBytes","constructor","v","options","checkSafeUint53","result","unshift","allowMissingPrefix","substring","hexPad","concat","items","objects","map","item","reduce","accum","offset","object","match","HexCharacters","hexlify","Math","floor","hexDataSlice","endOffset","hexZeroPad","BN","_BN","_constructorGuard","MAX_SAFE","_warnedToStringRadix","BigNumber","constructorGuard","_hex","_isBigNumber","freeze","toBigNumber","toBN","fromTwos","toTwos","other","add","sub","isZero","throwFault","div","mul","isNeg","umod","pow","isNegative","and","or","xor","maskn","shln","shrn","eq","lt","lte","gt","gte","toNumber","BigInt","e","type","toHex","anyValue","defineReadOnly","getStatic","ctor","getPrototypeOf","resolveProperties","promises","then","all","results","shallowCopy","opaque","bigint","boolean","number","string","_isFrozen","isFrozen","_deepCopy","deepCopy","Description","Coder","localName","dynamic","Writer","wordSize","_data","_dataLength","_padding","hexConcat","writer","_writeData","bytes","paddingOffset","_getValue","Reader","coerceFunc","allowLoose","_offset","_coerceFunc","coerce","loose","alignedLength","ceil","_peekBytes","readBytes","keccak256","sha3","arrayifyInteger","_encode","child","encode","getChecksumAddress","address","chars","expanded","charCodeAt","hashed","toUpperCase","ibanLookup","x","safeDigits","log10","LN10","ibanChecksum","c","block","checksum","getAddress","getContractAddress","start","stripZeros","nonce","UnicodeNormalizationForm","Utf8ErrorReason","ignoreFunc","output","badCodepoint","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","Utf8ErrorFuncs","ignore","replace","OVERLONG","getUtf8CodePoints","onError","extraLength","overlongMask","res","j","nextChar","MISSING_CONTINUE","OUT_OF_RANGE","UTF16_SURROGATE","toUtf8Bytes","str","current","checkNormalize","c2","pair","toUtf8String","codePoint","text","AddressCoder","_throwError","writeValue","reader","readValue","AnonymousCoder","coder","defaultValue","decode","pack","coders","values","arrayValues","unique","staticWriter","dynamicWriter","updateFuncs","index","dynamicOffset","updateFunc","writeUpdatableValue","baseOffset","func","appendWriter","unpack","baseReader","subReader","offsetReader","baseType","uniqueNames","ArrayCoder","defaultChild","checkArgumentCount","BooleanCoder","DynamicBytesCoder","writeBytes","BytesCoder","FixedBytesCoder","size","NullCoder","NegativeOne","Zero","One","MaxUint256","NumberCoder","signed","maxUintValue","mask","bounds","StringCoder","TupleCoder","types","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","indexOf","populate","FormatTypes","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","arrayLength","arrayChildren","fromObject","components","_isParamType","format","indexed","comp","parse","allowIndexed","fromString","isParamType","verifyType","node","param","originalParam","newNode","state","allowType","allowParams","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","depth","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","verifyState","isConstructorFragment","parens","outputs","isFunctionFragment","returns","checkForbidden","fragment","sig","isErrorFragment","regexIdentifier","paramTypeBytes","paramTypeNumber","AbiCoder","_getCoder","component","_getWordSize","_getWriter","_getReader","defaultAbiCoder","LogDescription","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","wrapAccessError","property","wrap","TransactionTypes","fragments","filter","bucket","deploy","functions","events","abi","nameOrSignatureOrSighash","getSighash","matching","f","nameOrSignatureOrTopic","topichash","getEventTopic","getFunction","getError","_","eventFragment","getEvent","_abiCoder","_encodeParams","_decodeParams","functionFragment","errorArgs","errorName","errorSignature","selector","builtin","topics","encodeTopic","pop","dataTypes","dataValues","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","hash","tx","topic","decodeEventLog","hexData","errorFragment","_isInterface","Provider","checkAbstract","getBlock","gasPrice","catch","lastBaseFeePerGas","maxFeePerGas","maxPriorityFeePerGas","baseFeePerGas","eventName","listener","on","_isProvider","allowedTransactionKeys","forwardErrors","Signer","blockTag","_checkProvider","provider","checkTransaction","estimateGas","populateTransaction","signTransaction","signedTx","sendTransaction","getNetwork","network","chainId","getFeeData","resolveName","__awaiter","hasEip1559","feeData","gasLimit","getChainId","_isSigner","VoidSigner","_fail","domain","accessSetify","addr","storageKeys","storageKey","hexDataLength","accessListify","sort","a","b","localeCompare","accessList","customData","ccipReadEnabled","resolver","nameOrPromise","resolveAddresses","paramType","contract","overrides","signer","override","resolvedAddress","resolved","interface","ro","intrinsic","roValue","leftovers","l","addContractWait","wait","confirmations","receipt","logs","event","parsed","parseLog","eventSignature","removeListener","blockHash","getTransaction","transactionHash","buildCall","collapseSimple","signerOrProvider","deployTransaction","_deployed","decodeFunctionResult","buildDefault","txRequest","buildSend","getEventTag","RunningEvent","tag","_listeners","once","done","listenerCount","argsCopy","setTimeout","ErrorRunningEvent","FragmentRunningEvent","contractInterface","decodeError","checkErrors","path","childPath","checkResultErrors","WildcardRunningEvent","BaseContract","addressOrName","isSigner","isProvider","uniqueFilters","filters","encodeFilterTopics","uniqueSignatures","callStatic","buildPopulate","buildEstimate","signatures","_deployedPromise","contractAddress","deployed","runningEvent","_runningEvents","_normalizeRunningEvent","emit","_wrappedEmits","_checkRunningEvents","prepareEvent","addListener","wrappedEmit","_wrapEvent","getEmit","fromBlockOrBlockhash","toBlock","_getRunningEvent","fromBlock","getLogs","_addEventListener","run","listeners","removeAllListeners","isInterface","isIndexed","Contract","ContractFactory","bytecode","bytecodeHex","encodeDeploy","unsignedTx","getDeployTransaction","getContract","compilerOutput","evm","getInterface","zeros","getMultiplier","decimals","formatFixed","multiplier","negative","fraction","mod","whole","parseFixed","wholeValue","fractionValue","wei","FixedFormat","width","_multiplier","FixedNumber","_value","_isFixedNumber","_checkFormat","fromValue","hasFraction","subUnsafe","ONE","toFormat","addUnsafe","factor","bump","BUMP","mulUnsafe","divUnsafe","parseFloat","isBigNumber","isBigNumberish","fixedFormat","numeric","decimal","fromBytes","splitSignature","r","s","_vs","recoveryParam","yParityAndS","compact","vs","zeroPad","recId","joinSignature","padding","fill","hexTrue","hexFalse","domainFieldTypes","verifyingContract","salt","domainFieldNames","checkString","domainChecks","getBaseEncoder","boundsUpper","boundsLower","padOffset","hexPadRight","encodeType","fields","SupportedAlgorithm","TypedDataEncoder","links","parents","subtypes","field","primaryTypes","n","t","checkCircular","found","subtype","primaryType","st","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","encodeData","hashStruct","callback","_visit","domainFields","EIP712Domain","hashDomain","ensCache","visit","domainValues","domainTypes","typesWithDomain","BaseX","alphabet","charAt","_alphabetMap","digits","carry","base","k","_leader","q","TypeError","byte","reverse","Base58","sha256","update","digest","computeHmac","algorithm","assert","val","equal","zero2","word","toArray","enc","hi","lo","minAssert","minUtils","getNAF","num","w","bits","naf","max","bitLength","ws","clone","z","andln","isOdd","isubn","iushrn","getJSF","k1","k2","jsf","m8","d1","d2","cmpn","u1","u2","m14","m24","cachedProperty","obj","computer","parseBytes","intFromLE","BaseCurve","conf","p","red","prime","zero","toRed","one","two","g","pointFromJSON","gRed","_wnafT1","_wnafT2","_wnafT3","_wnafT4","_bitLength","adjustCount","redN","_maxwellTrick","BasePoint","curve","precomputed","point","validate","_fixedNafMul","doubles","_getDoubles","I","step","nafW","repr","jpoint","mixedAdd","points","neg","toP","_wnafMul","nafPoints","_getNAFPoints","wnd","acc","dblp","_wnafMulAdd","defW","coeffs","jacobianResult","wndWidth","comb","y","cmp","toJ","redNeg","ja","jb","tmp","decodePoint","byteLength","pointFromX","encodeCompressed","getX","getY","isEven","precompute","power","beta","_getBeta","_hasDoubles","dbl","create","module","superCtor","super_","configurable","TempCtor","ShortCurve","Base","tinv","redInvm","zeroA","fromRed","threeA","endo","_getEndomorphism","_endoWnafT1","_endoWnafT2","inherits","Point","isRed","inf","forceRed","JPoint","zOne","modn","lambda","betas","_getEndoRoots","lambdas","redMul","basis","vec","_getEndoBasis","ntinv","redSqrt","redAdd","redSub","a0","b0","a1","b1","a2","b2","prevR","aprxSqrt","ushrn","u","x1","y1","x2","y2","len1","sqr","_endoSplit","v1","v2","c1","divRound","p1","p2","q1","q2","odd","redSqr","redIAdd","ax","rhs","redISub","_endoWnafMulAdd","npoints","ncoeffs","ineg","fromJSON","pre","endoMul","toJSON","obj2point","inspect","isInfinity","nx","ny","ys1","dyinv","mulAdd","jmulAdd","_precompute","negate","zinv","zinv2","ay","pz2","z2","s1","s2","h","h2","h3","nz","jx","jy","jz","jz4","jyd","jx2","jyd2","jyd4","t1","t2","dny","_zeroDbl","_threeDbl","_dbl","xx","yy","yyyy","m","yyyy8","d","c8","delta","gamma","alpha","beta4","beta8","ggamma8","jy2","jxd4","jyd8","trpl","zz","mm","ee","yyu4","kbase","z3","pz3","eqXToP","zs","rx","xc","iadd","require$$0","short","require$$1","mont","edwards","curves","PresetCurve","defineCurve","HmacDRBG","predResist","outLen","outSize","minEntropy","hmacStrength","_reseed","reseedInterval","K","V","entropy","entropyEnc","nonceEnc","pers","persEnc","_init","seed","_update","_hmac","kmac","reseed","addEnc","generate","temp","KeyPair","ec","priv","pub","_importPrivate","privEnc","_importPublic","pubEnc","fromPublic","fromPrivate","getPublic","getPrivate","derive","sign","verify","Signature","_importDER","Position","place","getLength","buf","initial","octetLen","rmPadding","constructLength","octets","LN2","rlen","slen","toDER","backHalf","rand","EC","hasOwnProperty","nh","keyPair","keyFromPrivate","keyFromPublic","genKeyPair","drbg","ns2","iaddn","_truncateToN","truncOnly","bkey","ns1","iter","kp","kpX","invm","canonical","sinv","recoverPubKey","isYOdd","isSecondKey","rInv","getKeyRecoveryParam","Q","Qprime","elliptic","require$$2","require$$3","eddsa","_curve","getCurve","SigningKey","privateKey","p0","publicKey","digestBytes","otherKey","otherKeyPair","computePublicKey","_isSigningKey","compressed","signingKey","transactionFields","maxLength","computeAddress","recoverAddress","rs","recoverPublicKey","formatNumber","formatAccessList","_serializeEip1559","RLP","_serializeEip2930","_serialize","properties","raw","fieldInfo","serialize","transactionType","Wordlist","locale","mnemonic","words","wordlist","getWord","getWordIndex","lang","loadWords","langEn","register","wordlists","en","N","MasterSecret","HardenedBit","getUpperMask","bytes32","base58check","getWordlist","defaultPath","HDNode","parentFingerprint","chainCode","mnemonicOrPath","compressedPublicKey","IL","IR","ki","Ki","_addPoint","srcMnemonic","phrase","fingerprint","shift","_derive","seedArray","password","entropyToMnemonic","mnemonicToEntropy","_fromSeed","iterations","keylen","hashAlgorithm","hLen","T","DK","block1","U","destPos","pbkdf2","mnemonicToSeed","extendedKey","bit","entropyBits","checksumMask","indices","remainingBits","checksumBits","anyGlobal","self","global","getGlobal","msCrypto","buffer","LangEn","ripemd160","randomBytes","looseArrayify","hexString","zpad","getPassword","searchPath","currentChild","matchingChild","uuidV4","hasMnemonic","KeystoreAccount","_isKeystoreAccount","_getAccount","ciphertext","iv","counter","aes","aesCtr","decrypt","_decrypt","mnemonicKey","account","mnemonicCiphertext","mnemonicIv","mnemonicCounter","mnemonicAesCtr","derivePath","pbkdf2Sync","passwordBytes","dkLen","prfFunc","_pbkdf2","_computeKdfKey","pbkdf2Func","scryptFunc","progressCallback","kdf","prf","CrowdsaleAccount","_isCrowdsaleAccount","ethaddr","encseed","encryptedSeed","aesCbc","seedHex","seedHexBytes","isCrowdsaleWallet","isKeystoreWallet","getJsonWalletAddress","decryptJsonWallet","decryptCrowdsale","scrypt","decryptKeystore","decryptJsonWalletSync","decryptKeystoreSync","Wallet","fromMnemonic","isSigningKey","_mnemonic","_signingKey","signDigest","_TypedDataEncoder","populated","client","uuidRandom","uuid","derivedKey","macPrefix","encrypt","mac","Crypto","cipher","cipherparams","kdfparams","dklen","now","timestamp","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","gethFilename","encryptKeystore","extraEntropy","verifyMessage","verifyTypedData","AddressZero","Two","WeiPerEther","MinInt256","MaxInt256","HashZero","EtherSymbol","isAddress","getIcapAddress","base36","getCreate2Address","initCodeHash","textData","atob","btoa","hexValue","trimmed","hexStripZeros","_toUtf8String","codePoints","toUtf8CodePoints","createTable","createRangeTable","matchMap","ranges","range","Table_A_1_ranges","Table_B_1_flags","Table_B_2_ranges","Table_B_2_lut_abs","Table_B_2_lut_rel","Table_B_2_complex","Table_C_ranges","nameprep","codes","codesTableB2","codepoint","_nameprepTableB2","Zeros","Partition","isValidName","namehash","partition","dnsEncode","isValidMnemonic","getAccountPath","sha512","regexBytes","regexNumber","regexArray","_pack","tight","shuffled","random","checkProperties","unarrayifyInteger","_decodeChildren","childOffset","decoded","_decode","consumed","lengthLength","escapeChar","_toEscapedUtf8String","formatBytes32String","parseBytes32String","handleAddress","handleNumber","_parseEipSignature","recid","rawTransaction","_parse","_parseEip2930","_parseEip1559","names","commify","suffix","formatted","formatUnits","unitName","parseUnits","formatEther","parseEther","ether","getUrl","href","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetch","arrayBuffer","statusCode","status","statusMessage","statusText","staller","duration","bodyify","_fetchData","connection","processFunc","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","errorPassThrough","allow304","timeout","allowGzip","user","allowInsecureAuthentication","authorization","base64Encode","reData","dataMatch","base64Decode","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","serverError","throttleRetry","race","fetchJson","updated","poll","ceiling","interval","retryLimit","oncePoll","onceBlock","_ethers","ethers","__self__","F","DOMException","support","Symbol","Blob","viewClasses","isArrayBufferView","ArrayBuffer","isView","normalizeName","normalizeValue","iteratorFor","iterator","next","Headers","append","getOwnPropertyNames","bodyUsed","fileReaderReady","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","bufferClone","view","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","rejected","readAsText","formData","oldValue","has","thisArg","entries","methods","Request","upcased","signal","decodeURIComponent","Response","bodyInit","ok","redirectStatuses","RangeError","err","stack","init","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","parts","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","onreadystatechange","readyState","removeEventListener","polyfill","ponyfill","ctx","default","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","definition","prop","toStringTag","SafeAppAccessPolicyTypes","Operation","TransactionStatus","TransferDirection","TransactionTokenType","LabelValue","RPC_AUTHENTICATION","GAS_PRICE_TYPE","FEATURES","TokenType","fetchData","resp","errTxt","callEndpoint","baseUrl","parameters","rawUrl","template","query","searchParams","searchString","getBalances","getFiatCurrencies","getOwnedSafes","getCollectibles","getTransactionHistory","pageUrl","safe_address","getTransactionQueue","getTransactionDetails","transactionId","postSafeGasEstimation","proposeTransaction","getChainsConfig","getChainConfig","getSafeApps","getMasterCopies","getDecodedData","encodedData"],"sourceRoot":""}