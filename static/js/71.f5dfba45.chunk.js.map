{"version":3,"file":"static/js/71.f5dfba45.chunk.js","mappings":"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","sources":["../node_modules/ethers/node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/basex/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/idna.ts","../node_modules/ethers/node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/ethers/node_modules/@ethersproject/hash/src.ts/message.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/json-wallets/src.ts/inspect.ts","../node_modules/ethers/node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/sha2/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/ethers/node_modules/@ethersproject/random/src.ts/shuffle.ts","../node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/rlp/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/ethers/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/strings/src.ts/idna.ts","../node_modules/ethers/node_modules/@ethersproject/strings/src.ts/bytes32.ts","../node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abi/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/abstract-signer/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/ethers/node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/contracts/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/hash/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/properties/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/random/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/random/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/random/src.ts/browser-random.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/solidity/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/strings/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/address/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/message.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/basex/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/pbkdf2/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/pbkdf2/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/src.ts/types.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/pbkdf2/src.ts/browser-pbkdf2.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/keccak256/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/random/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/random/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/random/src.ts/browser-random.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/src.ts/wordlist.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/src.ts/lang-en.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/wordlists/src.ts/browser-wordlists.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/hdnode/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/node_modules/@ethersproject/random/src.ts/browser-random.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/src.ts/utils.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/src.ts/keystore.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/src.ts/crowdsale.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/src.ts/inspect.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/json-wallets/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/rlp/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-assert/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/minimalistic-crypto-utils/lib/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/utils.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/base.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/inherits/inherits_browser.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/short.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curve/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/curves.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/hmac-drbg/lib/hmac-drbg.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/key.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/signature.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic/ec/index.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/lib.esm/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/node_modules/elliptic/lib/elliptic.js","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/node_modules/@ethersproject/signing-key/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/node_modules/@ethersproject/transactions/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/wallet/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/web/node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/ethers/node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/ethers/node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/ethers/node_modules/@ethersproject/web/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\n\ntype Ranged = {\n    l: number,          // Lo value\n    h: number,          // High value (less the lo)\n    d?: number,         // Delta/stride (default: 1)\n    s?: number,         // Shift (default: 1)\n    e?: Array<number>   // Exceptions to skip\n};\n\ntype Table = { [ src: number ]: Array<number> };\n\nfunction bytes2(data: string): Array<number> {\n    if ((data.length % 4) !== 0) { throw new Error(\"bad data\"); }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\n\nfunction createTable(data: string, func?: (value: string) => Array<number>): Table {\n    if (!func) {\n        func = function(value: string) { return [ parseInt(value, 16) ]; }\n    }\n\n    let lo = 0;\n\n    let result: Table = { };\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n\n    return result;\n}\n\nfunction createRangeTable(data: string): Array<Ranged> {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\n\nfunction matchMap(value: number, ranges: Array<Ranged>): Ranged {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) { continue; }\n            return range;\n        }\n    }\n    return null;\n}\n\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\n\nconst Table_B_2_ranges: Array<Ranged> = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [ 23 ], l: 127 },\n    { h: 54, s: 1, e: [ 48 ], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [ 2, 6, 8 ], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [ 18, 24, 66 ], l: 19, d: 2 },\n    { h: 26, s: 32, e: [ 17 ], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [ 38 ], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [ 1, 4, 5, 7, 8, 11, 12, 17 ], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [ 2, 7, 8, 17 ], l: 52 },\n    { h: 24, s: -120023, e: [ 2, 7, 13, 15, 16, 17 ], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [ 17 ], l: 56 },\n    { h: 24, s: -119601, e: [ 17 ], l: 58 },\n    { h: 24, s: -119659, e: [ 17 ], l: 58 },\n    { h: 24, s: -119717, e: [ 17 ], l: 58 },\n    { h: 24, s: -119775, e: [ 17 ], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\n\nfunction flatten(values: Array<Array<number>>): Array<number> {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, [ ]);\n}\n\nexport function _nameprepTableA1(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\n\nexport function _nameprepTableB2(codepoint: number): Array<number> {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) { return [ codepoint + range.s ]; }\n\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) { return codes; }\n\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) { return [ codepoint + shift[0] ]; }\n\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) { return complex; }\n\n    return null;\n}\n\nexport function _nameprepTableC(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\n\nexport function nameprep(value: string): string {\n\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) { return value.toLowerCase(); }\n\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) { return [ ]; }\n        if (code >= 0xfe00 && code <= 0xfe0f) { return [ ]; }\n\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) { return codesTableB2; }\n\n        // No Substitution\n        return [ code ];\n    }));\n\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n\n    // IDNA extras\n    let name = _toUtf8String(codes);\n\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n\n    // IDNA: 4.2.4\n    if (name.length > 63) { throw new Error(\"too long\"); }\n\n\n\n    return name;\n}\n\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\n\nexport function isValidName(name: string): boolean {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\")\n            }\n        }\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let current = name;\n    let result: string | Uint8Array = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n\n        current = partition[2] || \"\";\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(name.split(\".\").map((comp) => {\n        // We jam in an _ prefix to fill in with the length later\n        // Note: Nameprep throws if the component is over 63 bytes\n        const bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n","import { Bytes, concat } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport const messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n\nexport function hashMessage(message: Bytes | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(messagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","export const version = \"sha2/5.7.0\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"signing-key/5.6.2\";\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","export const version = \"sha2/5.6.1\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.7.0\";\n","export const version = \"transactions/5.6.2\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","export const version = \"wordlists/5.6.1\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        logger.checkNew(new.target, HDNode);\n\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.6.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"address/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\n\n\nexport function isCrowdsaleWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    return (data.encseed && data.ethaddr);\n}\n\nexport function isKeystoreWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n        return false;\n    }\n\n    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n    return true;\n}\n\n//export function isJsonWallet(json: string): boolean {\n//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n//}\n\nexport function getJsonWalletAddress(json: string): string {\n    if (isCrowdsaleWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).ethaddr);\n        } catch (error) { return null; }\n    }\n\n    if (isKeystoreWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).address);\n        } catch (error) { return null; }\n    }\n\n    return null;\n}\n\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"sha2/5.6.0\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","\"use strict\";\n\nexport function shuffled(array: Array<any>): Array<any> {\n    array = array.slice();\n\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n\n    return array;\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"rlp/5.6.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.6.1\";\n","\"use strict\";\n\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\n\ntype Ranged = {\n    l: number,          // Lo value\n    h: number,          // High value (less the lo)\n    d?: number,         // Delta/stride (default: 1)\n    s?: number,         // Shift (default: 1)\n    e?: Array<number>   // Exceptions to skip\n};\n\ntype Table = { [ src: number ]: Array<number> };\n\nfunction bytes2(data: string): Array<number> {\n    if ((data.length % 4) !== 0) { throw new Error(\"bad data\"); }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\n\nfunction createTable(data: string, func?: (value: string) => Array<number>): Table {\n    if (!func) {\n        func = function(value: string) { return [ parseInt(value, 16) ]; }\n    }\n\n    let lo = 0;\n\n    let result: Table = { };\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n\n    return result;\n}\n\nfunction createRangeTable(data: string): Array<Ranged> {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\n\nfunction matchMap(value: number, ranges: Array<Ranged>): Ranged {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) { continue; }\n            return range;\n        }\n    }\n    return null;\n}\n\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\n\nconst Table_B_2_ranges: Array<Ranged> = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [ 23 ], l: 127 },\n    { h: 54, s: 1, e: [ 48 ], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [ 2, 6, 8 ], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [ 18, 24, 66 ], l: 19, d: 2 },\n    { h: 26, s: 32, e: [ 17 ], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [ 38 ], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [ 1, 4, 5, 7, 8, 11, 12, 17 ], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [ 2, 7, 8, 17 ], l: 52 },\n    { h: 24, s: -120023, e: [ 2, 7, 13, 15, 16, 17 ], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [ 17 ], l: 56 },\n    { h: 24, s: -119601, e: [ 17 ], l: 58 },\n    { h: 24, s: -119659, e: [ 17 ], l: 58 },\n    { h: 24, s: -119717, e: [ 17 ], l: 58 },\n    { h: 24, s: -119775, e: [ 17 ], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\n\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\n\n\nfunction flatten(values: Array<Array<number>>): Array<number> {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, [ ]);\n}\n\nexport function _nameprepTableA1(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\n\nexport function _nameprepTableB2(codepoint: number): Array<number> {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) { return [ codepoint + range.s ]; }\n\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) { return codes; }\n\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) { return [ codepoint + shift[0] ]; }\n\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) { return complex; }\n\n    return null;\n}\n\nexport function _nameprepTableC(codepoint: number): boolean {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\n\nexport function nameprep(value: string): string {\n\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) { return value.toLowerCase(); }\n\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) { return [ ]; }\n        if (code >= 0xfe00 && code <= 0xfe0f) { return [ ]; }\n\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) { return codesTableB2; }\n\n        // No Substitution\n        return [ code ];\n    }));\n\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n\n    // IDNA extras\n    let name = _toUtf8String(codes);\n\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n\n    // IDNA: 4.2.4\n    if (name.length > 63) { throw new Error(\"too long\"); }\n\n\n\n    return name;\n}\n\n","\"use strict\";\n\nimport { HashZero } from \"@ethersproject/constants\";\nimport { arrayify, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\n\nimport { toUtf8Bytes, toUtf8String } from \"./utf8\";\n\n\nexport function formatBytes32String(text: string): string {\n\n    // Get the bytes\n    const bytes = toUtf8Bytes(text);\n\n    // Check we have room for null-termination\n    if (bytes.length > 31) { throw new Error(\"bytes32 string must be less than 32 bytes\"); }\n\n    // Zero-pad (implicitly null-terminates)\n    return hexlify(concat([ bytes, HashZero ]).slice(0, 32));\n}\n\nexport function parseBytes32String(bytes: BytesLike): string {\n    const data = arrayify(bytes);\n\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) { throw new Error(\"invalid bytes32 - not 32 bytes long\"); }\n    if (data[31] !== 0) { throw new Error(\"invalid bytes32 string - no null terminator\"); }\n\n    // Find the null termination\n    let length = 31;\n    while (data[length - 1] === 0) { length--; }\n\n    // Determine the string value\n    return toUtf8String(data.slice(0, length));\n}\n\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","export const version = \"abi/5.6.1\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"strings/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        logger.checkNew(new.target, Interface);\n\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","export const version = \"address/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        logger.checkNew(new.target, VoidSigner);\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"rlp/5.6.1\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","export const version = \"address/5.6.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"bignumber/5.6.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        logger.checkNew(new.target, BigNumber);\n\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"abi/5.6.4\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            }\n\n            if (param.type.match(/^u?int/)) {\n                value = BigNumber.from(value).toHexString();\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = eventFragment.inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"abstract-provider/5.6.1\";\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.2\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"rlp/5.7.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","export const version = \"address/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"transactions/5.6.2\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"contracts/5.6.0\";\n","\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        logger.checkNew(new.target, Contract);\n\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n","export const version = \"hash/5.6.0\";\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","export const version = \"address/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"strings/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.6.0\";\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"properties/5.6.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"random/5.6.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Debugging line for testing browser lib in node\n//const window = { crypto: { getRandomValues: () => { } } };\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\n\nlet crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\nif (!crypto || !crypto.getRandomValues) {\n\n    logger.warn(\"WARNING: Missing strong random number source\");\n\n    crypto = {\n        getRandomValues: function(buffer: Uint8Array): Uint8Array {\n            return logger.throwError(\"no secure random source avaialble\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"crypto.getRandomValues\"\n            });\n        }\n    };\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n        logger.throwArgumentError(\"invalid length\", \"length\", length);\n    }\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return arrayify(result);\n};\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.6.1\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","export const version = \"solidity/5.6.0\";\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\n    switch(type) {\n        case \"address\":\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return arrayify(value);\n        case \"bool\":\n            value = (value ? \"0x01\": \"0x00\");\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n    }\n\n    let match =  type.match(regexNumber);\n    if (match) {\n        //let signed = (match[1] === \"int\")\n        let size = parseInt(match[2] || \"256\")\n\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n            logger.throwArgumentError(\"invalid number type\", \"type\", type)\n        }\n\n        if (isArray) { size = 256; }\n\n        value = BigNumber.from(value).toTwos(size);\n\n        return zeroPad(value, size / 8);\n    }\n\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n\n        if (String(size) !== match[1] || size === 0 || size > 32) {\n            logger.throwArgumentError(\"invalid bytes type\", \"type\", type)\n        }\n        if (arrayify(value).byteLength !== size) {\n            logger.throwArgumentError(`invalid value for ${ type }`, \"value\", value)\n        }\n        if (isArray) { return arrayify((value + Zeros).substring(0, 66)); }\n        return value;\n    }\n\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        if (count != value.length) {\n            logger.throwArgumentError(`invalid array length for ${ type }`, \"value\", value)\n        }\n        const result: Array<Uint8Array> = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return concat(result);\n    }\n\n    return logger.throwArgumentError(\"invalid type\", \"type\", type)\n}\n\n// @TODO: Array Enum\n\nexport function pack(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    if (types.length != values.length) {\n        logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values)\n    }\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n\nexport function keccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashKeccak256(pack(types, values));\n}\n\nexport function sha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashSha256(pack(types, values));\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"strings/5.6.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","export const version = \"address/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.6.2\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"rlp/5.6.1\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"signing-key/5.6.2\";\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"transactions/5.6.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) {\n        console.log(error);\n    }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        console.log(error);\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) {\n            console.log(error);\n        }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","export const version = \"address/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","export const version = \"abstract-provider/5.6.1\";\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.6.2\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { Bytes, concat } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport const messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n\nexport function hashMessage(message: Bytes | string): string {\n    if (typeof(message) === \"string\") { message = toUtf8Bytes(message); }\n    return keccak256(concat([\n        toUtf8Bytes(messagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","export const version = \"hash/5.6.1\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n","export const version = \"sha2/5.7.0\";\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac, SupportedAlgorithm } from \"@ethersproject/sha2\";\n\nexport function pbkdf2(password: BytesLike, salt: BytesLike, iterations: number, keylen: number, hashAlgorithm: string): string {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen)\n    const block1 = new Uint8Array(salt.length + 4)\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n\n    let r: number;\n    let T: Uint8Array;\n\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, block1));\n\n        if (!hLen) {\n            hLen = U.length\n            T = new Uint8Array(hLen)\n            l = Math.ceil(keylen / hLen)\n            r = keylen - (l - 1) * hLen\n        }\n\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n\n\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(<SupportedAlgorithm>hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++) T[k] ^= U[k]\n        }\n\n\n        const destPos = (i - 1) * hLen\n        const len = (i === l ? r : hLen)\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n\n    return hexlify(DK)\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"transactions/5.7.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"wordlists/5.7.0\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.6.2\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"random/5.6.1\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Debugging line for testing browser lib in node\n//const window = { crypto: { getRandomValues: () => { } } };\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\n\nlet crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\nif (!crypto || !crypto.getRandomValues) {\n\n    logger.warn(\"WARNING: Missing strong random number source\");\n\n    crypto = {\n        getRandomValues: function(buffer: Uint8Array): Uint8Array {\n            return logger.throwError(\"no secure random source avaialble\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"crypto.getRandomValues\"\n            });\n        }\n    };\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n        logger.throwArgumentError(\"invalid length\", \"length\", length);\n    }\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return arrayify(result);\n};\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"signing-key/5.6.2\";\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.7.0\";\n","export const version = \"transactions/5.7.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"wordlists/5.7.0\";\n","\"use strict\";\n\n// This gets overridden by rollup\nconst exportWordlist = false;\n\nimport { id } from \"@ethersproject/hash\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nexport const logger = new Logger(version);\n\nexport abstract class Wordlist {\n    readonly locale: string;\n\n    constructor(locale: string) {\n        logger.checkAbstract(new.target, Wordlist);\n        defineReadOnly(this, \"locale\", locale);\n    }\n\n    abstract getWord(index: number): string;\n    abstract getWordIndex(word: string): number;\n\n    // Subclasses may override this\n    split(mnemonic: string): Array<string> {\n        return mnemonic.toLowerCase().split(/ +/g)\n    }\n\n    // Subclasses may override this\n    join(words: Array<string>): string {\n        return words.join(\" \");\n    }\n\n    static check(wordlist: Wordlist): string {\n        const words = [];\n        for (let i = 0; i < 2048; i++) {\n            const word = wordlist.getWord(i);\n            /* istanbul ignore if */\n            if (i !== wordlist.getWordIndex(word)) { return \"0x\"; }\n            words.push(word);\n        }\n        return id(words.join(\"\\n\") + \"\\n\");\n    }\n\n    static register(lang: Wordlist, name?: string): void {\n        if (!name) { name = lang.locale; }\n\n        /* istanbul ignore if */\n        if (exportWordlist) {\n            try {\n                const anyGlobal = (window as any)\n                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n                    if (!anyGlobal._ethers.wordlists[name]) {\n                         defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n                    }\n                }\n            } catch (error) { }\n        }\n    }\n\n}\n\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { Wordlist } from \"./wordlist\";\n\n\nconst words = \"AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo\";\n\nlet wordlist: Array<string> = null;\n\n\nfunction loadWords(lang: Wordlist): void {\n    if (wordlist != null) { return; }\n    wordlist = words.replace(/([A-Z])/g, \" $1\").toLowerCase().substring(1).split(\" \");\n\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */\n    if (Wordlist.check(lang) !== \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\") {\n        wordlist = null;\n        throw new Error(\"BIP39 Wordlist for en (English) FAILED\");\n    }\n}\n\nclass LangEn extends Wordlist {\n    constructor() {\n        super(\"en\");\n    }\n\n    getWord(index: number): string {\n        loadWords(this);\n        return wordlist[index];\n    }\n\n    getWordIndex(word: string): number {\n        loadWords(this);\n        return wordlist.indexOf(word);\n    }\n}\n\nconst langEn = new LangEn();\nWordlist.register(langEn);\n\nexport { langEn };\n","\"use strict\";\n\n// Wordlists\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n// Browser; only include English by default\n\nimport { Wordlist } from \"./wordlist\";\n\nimport { langEn as en } from \"./lang-en\";\n\nexport const wordlists: { [ locale: string ]: Wordlist } = {\n  en: en\n}\n","\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n","export const version = \"hdnode/5.7.0\";\n","export const version = \"random/5.7.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Debugging line for testing browser lib in node\n//const window = { crypto: { getRandomValues: () => { } } };\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\n\nlet crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\nif (!crypto || !crypto.getRandomValues) {\n\n    logger.warn(\"WARNING: Missing strong random number source\");\n\n    crypto = {\n        getRandomValues: function(buffer: Uint8Array): Uint8Array {\n            return logger.throwError(\"no secure random source avaialble\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"crypto.getRandomValues\"\n            });\n        }\n    };\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\n        logger.throwArgumentError(\"invalid length\", \"length\", length);\n    }\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return arrayify(result);\n};\n","\"use strict\";\n\nimport { arrayify, Bytes, BytesLike, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from '@ethersproject/strings';\n\nexport function looseArrayify(hexString: string): Uint8Array {\n    if (typeof(hexString) === 'string' && hexString.substring(0, 2) !== '0x') {\n        hexString = '0x' + hexString;\n    }\n    return arrayify(hexString);\n}\n\nexport function zpad(value: String | number, length: number): String {\n    value = String(value);\n    while (value.length < length) { value = '0' + value; }\n    return value;\n}\n\nexport function getPassword(password: Bytes | string): Uint8Array {\n    if (typeof(password) === 'string') {\n        return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);\n    }\n    return arrayify(password);\n}\n\nexport function searchPath(object: any, path: string): string {\n    let currentChild = object;\n\n    const comps = path.toLowerCase().split('/');\n    for (let i = 0; i < comps.length; i++) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comps[i]) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        // Didn't find one. :'(\n        if (matchingChild === null) {\n            return null;\n        }\n\n        // Now check this child...\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = arrayify(randomBytes);\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n\n","export const version = \"json-wallets/5.6.1\";\n","\"use strict\";\n\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes, BytesLike, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, Mnemonic, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\n\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Exported Types\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\n}\n\nexport interface _KeystoreAccount {\n    address: string;\n    privateKey: string;\n    mnemonic?: Mnemonic;\n\n    _isKeystoreAccount: boolean;\n}\n\nexport class KeystoreAccount extends Description<_KeystoreAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: Mnemonic;\n\n    readonly _isKeystoreAccount: boolean;\n\n    isKeystoreAccount(value: any): value is KeystoreAccount {\n        return !!(value && value._isKeystoreAccount);\n    }\n}\n\nexport type ProgressCallback = (percent: number) => void;\n\nexport type EncryptOptions = {\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}\n\nfunction _decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): Uint8Array {\n    const cipher = searchPath(data, \"crypto/cipher\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"))\n        const counter = new aes.Counter(iv);\n\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n\n        return arrayify(aesCtr.decrypt(ciphertext));\n    }\n\n    return null;\n}\n\nfunction _getAccount(data: any, key: Uint8Array): KeystoreAccount {\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n        throw new Error(\"invalid password\");\n    }\n\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n    if (!privateKey) {\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"decrypt\"\n        });\n    }\n\n    const mnemonicKey = key.slice(32, 64);\n\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (check.substring(0, 2) !== \"0x\") { check = \"0x\" + check; }\n\n        if (getAddress(check) !== address) {\n            throw new Error(\"address mismatch\");\n        }\n    }\n\n    const account: _KeystoreAccount = {\n        _isKeystoreAccount: true,\n        address: address,\n        privateKey: hexlify(privateKey)\n    };\n\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n        try {\n            const mnemonic = entropyToMnemonic(entropy, locale);\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n\n            account.mnemonic = node.mnemonic;\n\n        } catch (error) {\n            // If we don't have the locale wordlist installed to\n            // read this mnemonic, just bail and don't set the\n            // mnemonic\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n                throw error;\n            }\n        }\n    }\n\n    return new KeystoreAccount(account);\n}\n\ntype ScryptFunc<T> = (pw: Uint8Array, salt: Uint8Array, n: number, r: number, p: number, dkLen: number, callback?: ProgressCallback) => T;\ntype Pbkdf2Func<T> = (pw: Uint8Array, salt: Uint8Array, c: number, dkLen: number, prfFunc: string) => T;\n\nfunction pbkdf2Sync(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Uint8Array {\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes: Uint8Array, salt: Uint8Array, count: number, dkLen: number, prfFunc: string): Promise<Uint8Array> {\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey<T>(data: any, password: Bytes | string, pbkdf2Func: Pbkdf2Func<T>, scryptFunc: ScryptFunc<T>, progressCallback?: ProgressCallback): T {\n    const passwordBytes = getPassword(password);\n\n    const kdf = searchPath(data, \"crypto/kdf\");\n\n    if (kdf && typeof(kdf) === \"string\") {\n        const throwError = function(name: string, value: any): never {\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n        }\n\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n\n            // Check for all required parameters\n            if (!N || !r || !p) { throwError(\"kdf\", kdf); }\n\n            // Make sure N is a power of 2\n            if ((N & (N - 1)) !== 0) { throwError(\"N\", N); }\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n\n            let prfFunc: string = null;\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\n            if (prf === \"hmac-sha256\") {\n                prfFunc = \"sha256\";\n            } else if (prf === \"hmac-sha512\") {\n                prfFunc = \"sha512\";\n            } else {\n                throwError(\"prf\", prf);\n            }\n\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) { throwError(\"dklen\", dkLen); }\n\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n        }\n    }\n\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\n\nexport function decryptSync(json: string, password: Bytes | string): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n    return _getAccount(data, key);\n}\n\nexport async function decrypt(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const key = await _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n}\n\n\nexport function encrypt(account: ExternallyOwnedAccount, password: Bytes | string, options?: EncryptOptions, progressCallback?: ProgressCallback): Promise<string> {\n\n    try {\n        // Check the address matches the private key\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n            throw new Error(\"address/privateKey mismatch\");\n        }\n\n        // Check the mnemonic (if any) matches the private key\n        if (hasMnemonic(account)) {\n            const mnemonic = account.mnemonic;\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n        }\n\n    } catch (e) {\n        return Promise.reject(e);\n    }\n\n    // The options are optional, so adjust the call as needed\n    if (typeof(options) === \"function\" && !progressCallback) {\n        progressCallback = options;\n        options = {};\n    }\n    if (!options) { options = {}; }\n\n    const privateKey: Uint8Array = arrayify(account.privateKey);\n    const passwordBytes = getPassword(password);\n\n    let entropy: Uint8Array = null\n    let path: string = null;\n    let locale: string = null;\n    if (hasMnemonic(account)) {\n        const srcMnemonic = account.mnemonic;\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n        path = srcMnemonic.path || defaultPath;\n        locale = srcMnemonic.locale || \"en\";\n    }\n\n    let client = options.client;\n    if (!client) { client = \"ethers.js\"; }\n\n    // Check/generate the salt\n    let salt: Uint8Array = null;\n    if (options.salt) {\n        salt = arrayify(options.salt);\n    } else {\n        salt = randomBytes(32);;\n    }\n\n    // Override initialization vector\n    let iv: Uint8Array = null;\n    if (options.iv) {\n        iv = arrayify(options.iv);\n        if (iv.length !== 16) { throw new Error(\"invalid iv\"); }\n    } else {\n       iv = randomBytes(16);\n    }\n\n    // Override the uuid\n    let uuidRandom: Uint8Array = null;\n    if (options.uuid) {\n        uuidRandom = arrayify(options.uuid);\n        if (uuidRandom.length !== 16) { throw new Error(\"invalid uuid\"); }\n    } else {\n        uuidRandom = randomBytes(16);\n    }\n\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) { N = options.scrypt.N; }\n        if (options.scrypt.r) { r = options.scrypt.r; }\n        if (options.scrypt.p) { p = options.scrypt.p; }\n    }\n\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\n        key = arrayify(key);\n\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\n        const derivedKey = key.slice(0, 16);\n        const macPrefix = key.slice(16, 32);\n\n        // This will be used to encrypt the mnemonic phrase (if any)\n        const mnemonicKey = key.slice(32, 64);\n\n        // Encrypt the private key\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n\n        // Compute the message authentication code, used to check the password\n        const mac = keccak256(concat([macPrefix, ciphertext]))\n\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n        const data: { [key: string]: any } = {\n            address: account.address.substring(2).toLowerCase(),\n            id: uuidV4(uuidRandom),\n            version: 3,\n            Crypto: {\n                cipher: \"aes-128-ctr\",\n                cipherparams: {\n                    iv: hexlify(iv).substring(2),\n                },\n                ciphertext: hexlify(ciphertext).substring(2),\n                kdf: \"scrypt\",\n                kdfparams: {\n                    salt: hexlify(salt).substring(2),\n                    n: N,\n                    dklen: 32,\n                    p: p,\n                    r: r\n                },\n                mac: mac.substring(2)\n            }\n        };\n\n        // If we have a mnemonic, encrypt it into the JSON wallet\n        if (entropy) {\n            const mnemonicIv = randomBytes(16);\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n            const now = new Date();\n            const timestamp = (now.getUTCFullYear() + \"-\" +\n                               zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                               zpad(now.getUTCDate(), 2) + \"T\" +\n                               zpad(now.getUTCHours(), 2) + \"-\" +\n                               zpad(now.getUTCMinutes(), 2) + \"-\" +\n                               zpad(now.getUTCSeconds(), 2) + \".0Z\"\n                              );\n            data[\"x-ethers\"] = {\n                client: client,\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n                path: path,\n                locale: locale,\n                version: \"0.1\"\n            };\n        }\n\n        return JSON.stringify(data);\n    });\n}\n","\"use strict\";\n\nimport aes from \"aes-js\";\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, Bytes } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Description } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\n\nexport interface _CrowdsaleAccount {\n    address: string;\n    privateKey: string;\n\n    _isCrowdsaleAccount: boolean;\n}\n\nexport class CrowdsaleAccount extends Description<_CrowdsaleAccount> implements ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n    readonly mnemonic?: string;\n    readonly path?: string;\n\n    readonly _isCrowdsaleAccount: boolean;\n\n    isCrowdsaleAccount(value: any): value is CrowdsaleAccount {\n        return !!(value && value._isCrowdsaleAccount);\n    }\n}\n\n// See: https://github.com/ethereum/pyethsaletool\nexport function decrypt(json: string, password: Bytes | string): ExternallyOwnedAccount {\n    const data = JSON.parse(json);\n\n    password = getPassword(password);\n\n    // Ethereum Address\n    const ethaddr = getAddress(searchPath(data, \"ethaddr\"));\n\n    // Encrypted Seed\n    const encseed = looseArrayify(searchPath(data, \"encseed\"));\n    if (!encseed || (encseed.length % 16) !== 0) {\n        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n    }\n\n    const key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n\n    // Decrypt the seed\n    const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n    const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));\n\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n\n    const seedHexBytes = toUtf8Bytes(seedHex);\n\n    const privateKey = keccak256(seedHexBytes);\n\n    return new CrowdsaleAccount ({\n        _isCrowdsaleAccount: true,\n        address: ethaddr,\n        privateKey: privateKey\n    });\n}\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\n\n\nexport function isCrowdsaleWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    return (data.encseed && data.ethaddr);\n}\n\nexport function isKeystoreWallet(json: string): boolean {\n    let data: any = null;\n    try {\n        data = JSON.parse(json);\n    } catch (error) { return false; }\n\n    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n        return false;\n    }\n\n    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n    return true;\n}\n\n//export function isJsonWallet(json: string): boolean {\n//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n//}\n\nexport function getJsonWalletAddress(json: string): string {\n    if (isCrowdsaleWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).ethaddr);\n        } catch (error) { return null; }\n    }\n\n    if (isKeystoreWallet(json)) {\n        try {\n            return getAddress(JSON.parse(json).address);\n        } catch (error) { return null; }\n    }\n\n    return null;\n}\n\n","\"use strict\";\n\nimport { Bytes } from \"@ethersproject/bytes\";\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\n\nimport { decrypt as decryptCrowdsale } from \"./crowdsale\";\nimport { getJsonWalletAddress, isCrowdsaleWallet, isKeystoreWallet } from \"./inspect\";\nimport { decrypt as decryptKeystore, decryptSync as decryptKeystoreSync, encrypt as encryptKeystore, EncryptOptions, ProgressCallback } from \"./keystore\";\n\nfunction decryptJsonWallet(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<ExternallyOwnedAccount> {\n    if (isCrowdsaleWallet(json)) {\n        if (progressCallback) { progressCallback(0); }\n        const account = decryptCrowdsale(json, password)\n        if (progressCallback) { progressCallback(1); }\n        return Promise.resolve(account);\n    }\n\n    if (isKeystoreWallet(json)) {\n        return decryptKeystore(json, password, progressCallback);\n    }\n\n    return Promise.reject(new Error(\"invalid JSON wallet\"));\n}\n\nfunction decryptJsonWalletSync(json: string, password: Bytes | string): ExternallyOwnedAccount {\n    if (isCrowdsaleWallet(json)) {\n        return decryptCrowdsale(json, password)\n    }\n\n    if (isKeystoreWallet(json)) {\n        return decryptKeystoreSync(json, password);\n    }\n\n    throw new Error(\"invalid JSON wallet\");\n}\n\nexport {\n    decryptCrowdsale,\n\n    decryptKeystore,\n    decryptKeystoreSync,\n    encryptKeystore,\n\n    isCrowdsaleWallet,\n    isKeystoreWallet,\n    getJsonWalletAddress,\n\n    decryptJsonWallet,\n    decryptJsonWalletSync,\n\n    ProgressCallback,\n    EncryptOptions,\n};\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"rlp/5.7.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n","'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n","'use strict';\n\nvar utils = exports;\nvar BN = require('bn.js');\nvar minAssert = require('minimalistic-assert');\nvar minUtils = require('minimalistic-crypto-utils');\n\nutils.assert = minAssert;\nutils.toArray = minUtils.toArray;\nutils.zero2 = minUtils.zero2;\nutils.toHex = minUtils.toHex;\nutils.encode = minUtils.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new BN(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar getNAF = utils.getNAF;\nvar getJSF = utils.getJSF;\nvar assert = utils.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new BN(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n\n  // Useful for many curves\n  this.zero = new BN(0).toRed(this.red);\n  this.one = new BN(1).toRed(this.red);\n  this.two = new BN(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new BN(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nmodule.exports = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar utils = require('../utils');\nvar BN = require('bn.js');\nvar inherits = require('inherits');\nvar Base = require('./base');\n\nvar assert = utils.assert;\n\nfunction ShortCurve(conf) {\n  Base.call(this, 'short', conf);\n\n  this.a = new BN(conf.a, 16).toRed(this.red);\n  this.b = new BN(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits(ShortCurve, Base);\nmodule.exports = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new BN(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new BN(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new BN(vec.a, 16),\n        b: new BN(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : BN.mont(num);\n  var tinv = new BN(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new BN(1);\n  var y1 = new BN(0);\n  var x2 = new BN(0);\n  var y2 = new BN(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new BN(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  Base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits(Point, Base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new BN(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  Base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new BN(0);\n  } else {\n    this.x = new BN(x, 16);\n    this.y = new BN(y, 16);\n    this.z = new BN(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits(JPoint, Base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new BN(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n","'use strict';\n\nvar curve = exports;\n\ncurve.base = require('./base');\ncurve.short = require('./short');\ncurve.mont = require('./mont');\ncurve.edwards = require('./edwards');\n","'use strict';\n\nvar curves = exports;\n\nvar hash = require('hash.js');\nvar curve = require('./curve');\nvar utils = require('./utils');\n\nvar assert = utils.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve.edwards(options);\n  else\n    this.curve = new curve.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: hash.sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: hash.sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: hash.sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = require('./precomputed/secp256k1');\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: hash.sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n","'use strict';\n\nvar hash = require('hash.js');\nvar utils = require('minimalistic-crypto-utils');\nvar assert = require('minimalistic-assert');\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils.toArray(options.pers, options.persEnc || 'hex');\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nmodule.exports = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new hash.hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils.toArray(entropy, entropyEnc);\n  add = utils.toArray(add, addEnc);\n\n  assert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new BN(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n","'use strict';\n\nvar BN = require('bn.js');\n\nvar utils = require('../utils');\nvar assert = utils.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert(options.r && options.s, 'Signature without r or s');\n  this.r = new BN(options.r, 16);\n  this.s = new BN(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nmodule.exports = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new BN(r);\n  this.s = new BN(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils.encode(res, enc);\n};\n","'use strict';\n\nvar BN = require('bn.js');\nvar HmacDRBG = require('hmac-drbg');\nvar utils = require('../utils');\nvar curves = require('../curves');\nvar rand = require('brorand');\nvar assert = utils.assert;\n\nvar KeyPair = require('./key');\nvar Signature = require('./signature');\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert(Object.prototype.hasOwnProperty.call(curves, options),\n      'Unknown curve ' + options);\n\n    options = curves[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nmodule.exports = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new KeyPair(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return KeyPair.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return KeyPair.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new BN(2));\n  for (;;) {\n    var priv = new BN(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new BN(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new HmacDRBG({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new BN(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new BN(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature, key, enc) {\n  msg = this._truncateToN(new BN(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature = new Signature(signature, 'hex');\n\n  // Perform primitive values validation\n  var r = signature.r;\n  var s = signature.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature, j, enc) {\n  assert((3 & j) === j, 'The recovery param is more than two bits');\n  signature = new Signature(signature, enc);\n\n  var n = this.n;\n  var e = new BN(msg);\n  var r = signature.r;\n  var s = signature.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {\n  signature = new Signature(signature, enc);\n  if (signature.recoveryParam !== null)\n    return signature.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n","import _ec from \"elliptic\";\nvar EC = _ec.ec;\nexport { EC };\n//# sourceMappingURL=elliptic.js.map","'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = require('../package.json').version;\nelliptic.utils = require('./elliptic/utils');\nelliptic.rand = require('brorand');\nelliptic.curve = require('./elliptic/curve');\nelliptic.curves = require('./elliptic/curves');\n\n// Protocols\nelliptic.ec = require('./elliptic/ec');\nelliptic.eddsa = require('./elliptic/eddsa');\n","\"use strict\";\n\nimport { EC } from \"./elliptic\";\n\nimport { arrayify, BytesLike, hexDataLength, hexlify, hexZeroPad, Signature, SignatureLike, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nlet _curve: EC = null\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\n\nexport class SigningKey {\n\n    readonly curve: string;\n\n    readonly privateKey: string;\n    readonly publicKey: string;\n    readonly compressedPublicKey: string;\n\n    //readonly address: string;\n\n    readonly _isSigningKey: boolean;\n\n    constructor(privateKey: BytesLike) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n\n    _addPoint(other: BytesLike): string {\n        const p0 =  getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 =  getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n\n    signDigest(digest: BytesLike): Signature {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        })\n    }\n\n    computeSharedSecret(otherKey: BytesLike): string {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n\n    static isSigningKey(value: any): value is SigningKey {\n        return !!(value && value._isSigningKey);\n    }\n}\n\nexport function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\n\nexport function computePublicKey(key: BytesLike, compressed?: boolean): string {\n    const bytes = arrayify(key);\n\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n\n    } else if (bytes.length === 33) {\n        if (compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n\n    } else if (bytes.length === 65) {\n        if (!compressed) { return hexlify(bytes); }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n\n","export const version = \"signing-key/5.7.0\";\n","export const version = \"transactions/5.6.2\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, DataOptions, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, isBytesLike, SignatureLike, splitSignature, stripZeros, } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { checkProperties } from \"@ethersproject/properties\";\nimport * as RLP from \"@ethersproject/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@ethersproject/signing-key\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    legacy = 0,\n    eip2930 = 1,\n    eip1559 = 2,\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessList;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\",    maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\",          length: 20 },\n    { name: \"value\",    maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, type: true, value: true\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serializeEip1559(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nfunction _serializeEip2930(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x01\", RLP.encode(fields)]);\n}\n\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    checkProperties(transaction, allowedTransactionKeys);\n\n    const raw: Array<string | Uint8Array> = [];\n\n    transactionFields.forEach(function(fieldInfo) {\n        let value = (<any>transaction)[fieldInfo.name] || ([]);\n        const options: DataOptions = { };\n        if (fieldInfo.numeric) { options.hexPad = \"left\"; }\n        value = arrayify(hexlify(value, options));\n\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value );\n            }\n        }\n\n        raw.push(hexlify(value));\n    });\n\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n\n        if (typeof(chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n\n    } else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return RLP.encode(raw);\n    }\n\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n             logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n         logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n\n    return RLP.encode(raw);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parseEip1559(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  2,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _parseEip2930(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const tx: Transaction = {\n        type:       1,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        gasPrice:   handleNumber(transaction[2]),\n        gasLimit:   handleNumber(transaction[3]),\n        to:         handleAddress(transaction[4]),\n        value:      handleNumber(transaction[5]),\n        data:       transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction: Uint8Array): Transaction {\n    const transaction = RLP.decode(rawTransaction);\n\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n\n    const tx: Transaction = {\n        nonce:    handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to:       handleAddress(transaction[3]),\n        value:    handleNumber(transaction[4]),\n        data:     transaction[5],\n        chainId:  0\n    };\n\n    // Legacy unsigned transaction\n    if (transaction.length === 6) { return tx; }\n\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n\n    } else {\n        // Signed Transaction\n\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) { tx.chainId = 0; }\n\n        let recoveryParam = tx.v - 27;\n\n        const raw = transaction.slice(0, 6);\n\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n\n        const digest = keccak256(RLP.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        } catch (error) { }\n\n        tx.hash = keccak256(rawTransaction);\n    }\n\n    tx.type = null;\n\n    return tx;\n}\n\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) { return _parse(payload); }\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n","export const version = \"wallet/5.6.0\";\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\nimport { Wordlist } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\n\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\n\n    readonly address: string;\n    readonly provider: Provider;\n\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\n    // leaking the private key in console.log; still, be careful! :)\n    readonly _signingKey: () => SigningKey;\n    readonly _mnemonic: () => Mnemonic;\n\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\n        logger.checkNew(new.target, Wallet);\n\n        super();\n\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => (\n                    {\n                        phrase: srcMnemonic.phrase,\n                        path: srcMnemonic.path || defaultPath,\n                        locale: srcMnemonic.locale || \"en\"\n                    }\n                ));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            } else {\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            }\n\n\n        } else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\n\n            } else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof(privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\n    get privateKey(): string { return this._signingKey().privateKey; }\n    get publicKey(): string { return this._signingKey().publicKey; }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    connect(provider: Provider): Wallet {\n        return new Wallet(this, provider);\n    }\n\n    signTransaction(transaction: TransactionRequest): Promise<string> {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\n            return serialize(<UnsignedTransaction>tx, signature);\n        });\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            if (this.provider == null) {\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"resolveName\",\n                    value: name\n                });\n            }\n            return this.provider.resolveName(name);\n        });\n\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    }\n\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\n        if (typeof(options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n\n        if (!options) { options = {}; }\n\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n\n\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options?: any): Wallet {\n        let entropy: Uint8Array = randomBytes(16);\n\n        if (!options) { options = { }; }\n\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\n        }\n\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\n        if (!path) { path = defaultPath; }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\n\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\n    return recoverAddress(hashMessage(message), signature);\n}\n\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"bytes/5.7.0\";\n","export const version = \"strings/5.6.1\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","export const version = \"web/5.6.0\";\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n    }\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64Decode(dataMatch[2])\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n"],"names":["decode","textData","atob","data","i","length","push","charCodeAt","arrayify","encode","String","fromCharCode","btoa","_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","error","off","_logLevel","_globalLogger","LogLevel","ErrorCode","_normalizeError","missing","forEach","form","normalize","Error","join","message","_checkNormalize","HEX","Logger","version","Object","defineProperty","this","enumerable","value","writable","logLevel","args","level","toLowerCase","throwArgumentError","console","log","apply","_log","levels","DEBUG","INFO","WARNING","code","params","makeError","errors","UNKNOWN_ERROR","messageDetails","keys","key","Uint8Array","hex","JSON","stringify","toString","reason","url","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","name","throwError","INVALID_ARGUMENT","argument","condition","UNSUPPORTED_OPERATION","operation","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","target","kind","censorship","permanent","globalLogger","warn","defineReadOnly","object","BaseX","alphabet","charAt","_alphabetMap","source","digits","carry","j","base","string","k","_leader","q","TypeError","bytes","byte","undefined","reverse","Base58","createTable","func","parseInt","lo","result","split","pair","comps","createRangeTable","hi","map","v","l","h","matchMap","ranges","range","d","e","indexOf","Table_A_1_ranges","Table_B_1_flags","Table_B_2_ranges","s","Table_B_2_lut_abs","Table_B_2_lut_rel","Table_B_2_complex","substring","Table_C_ranges","nameprep","match","values","codes","toUtf8CodePoints","codesTableB2","codepoint","shift","_nameprepTableB2","reduce","accum","_toUtf8String","UnicodeNormalizationForm","logger","Zeros","fill","Partition","RegExp","isValidName","namehash","current","partition","label","toUtf8Bytes","keccak256","concat","hexlify","dnsEncode","comp","hashMessage","isHexable","toHexString","addSlice","array","slice","Array","prototype","call","arguments","isInteger","isBytes","constructor","options","checkSafeUint53","unshift","allowMissingPrefix","isHexString","hexPad","HexCharacters","Math","floor","BN","_BN","_constructorGuard","MAX_SAFE","_warnedToStringRadix","BigNumber","constructorGuard","_hex","_isBigNumber","freeze","toBigNumber","toBN","fromTwos","toTwos","from","other","add","sub","isZero","throwFault","div","mul","isNeg","umod","pow","isNegative","and","or","xor","maskn","shln","shrn","eq","lt","lte","gt","gte","toNumber","BigInt","type","toHex","anyValue","Utf8ErrorReason","ignoreFunc","offset","output","badCodepoint","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","ignore","replace","OVERLONG","str","checkNormalize","c","c2","SupportedAlgorithm","computeHmac","algorithm","hash","update","digest","assert","val","msg","equal","r","utils","exports","zero2","word","res","toArray","enc","isArray","arr","minAssert","minUtils","getNAF","num","w","bits","naf","max","bitLength","ws","clone","z","mod","andln","isOdd","isubn","iushrn","getJSF","k1","k2","jsf","m8","d1","d2","cmpn","u1","u2","m14","m24","cachedProperty","obj","computer","parseBytes","intFromLE","BaseCurve","conf","p","red","prime","zero","toRed","one","two","n","g","pointFromJSON","gRed","_wnafT1","_wnafT2","_wnafT3","_wnafT4","_bitLength","adjustCount","redN","_maxwellTrick","BasePoint","curve","precomputed","point","validate","_fixedNafMul","doubles","_getDoubles","I","step","nafW","repr","a","jpoint","b","mixedAdd","points","neg","toP","_wnafMul","nafPoints","_getNAFPoints","wnd","acc","dblp","_wnafMulAdd","defW","coeffs","len","jacobianResult","wndWidth","comb","y","cmp","toJ","redNeg","index","ja","jb","tmp","decodePoint","byteLength","pointFromX","encodeCompressed","_encode","compact","x","getX","getY","isEven","precompute","power","beta","_getBeta","_hasDoubles","ceil","dbl","create","module","ctor","superCtor","super_","configurable","TempCtor","ShortCurve","Base","tinv","redInvm","zeroA","fromRed","threeA","endo","_getEndomorphism","_endoWnafT1","_endoWnafT2","inherits","Point","isRed","inf","forceRed","JPoint","zOne","modn","lambda","betas","_getEndoRoots","lambdas","redMul","basis","vec","_getEndoBasis","ntinv","redSqrt","redAdd","redSub","a0","b0","a1","b1","a2","b2","prevR","aprxSqrt","ushrn","u","x1","y1","x2","y2","len1","sqr","negative","_endoSplit","v1","v2","c1","divRound","p1","p2","q1","q2","odd","redSqr","redIAdd","ax","rhs","redISub","_endoWnafMulAdd","npoints","ncoeffs","ineg","fromJSON","pre","endoMul","toJSON","parse","obj2point","inspect","isInfinity","nx","ny","ys1","dyinv","mulAdd","jmulAdd","_precompute","negate","zinv","zinv2","ay","pz2","z2","s1","s2","h2","h3","nz","jx","jy","jz","jz4","jyd","jx2","jyd2","jyd4","t1","t2","dny","_zeroDbl","_threeDbl","_dbl","xx","yy","yyyy","m","t","yyyy8","f","c8","delta","gamma","alpha","beta4","beta8","ggamma8","jy2","jxd4","jyd8","trpl","zz","mm","ee","yyu4","kbase","z3","pz3","eqXToP","zs","rx","xc","iadd","require$$0","short","require$$1","mont","edwards","curves","PresetCurve","defineCurve","get","HmacDRBG","predResist","outLen","outSize","minEntropy","hmacStrength","_reseed","reseedInterval","K","V","entropy","entropyEnc","nonce","nonceEnc","pers","persEnc","_init","seed","_update","_hmac","kmac","reseed","addEnc","generate","temp","KeyPair","ec","priv","pub","_importPrivate","privEnc","_importPublic","pubEnc","fromPublic","fromPrivate","getPublic","getPrivate","derive","sign","verify","signature","Signature","_importDER","recoveryParam","Position","place","getLength","buf","initial","octetLen","rmPadding","constructLength","octets","LN2","rlen","slen","toDER","backHalf","rand","EC","hasOwnProperty","nh","keyPair","keyFromPrivate","keyFromPublic","genKeyPair","drbg","ns2","iaddn","_truncateToN","truncOnly","bkey","ns1","iter","kp","kpX","invm","canonical","sinv","recoverPubKey","isYOdd","isSecondKey","rInv","getKeyRecoveryParam","Q","Qprime","elliptic","require$$2","require$$3","eddsa","hexZeroPad","splitSignature","_vs","yParityAndS","vs","set","zeroPad","recId","_curve","getCurve","SigningKey","privateKey","hexDataLength","p0","publicKey","digestBytes","otherKey","otherKeyPair","computePublicKey","_isSigningKey","compressed","signingKey","sha256","sha3","getChecksumAddress","address","chars","expanded","hashed","toUpperCase","ibanLookup","safeDigits","log10","LN10","ibanChecksum","block","checksum","getAddress","hexDataSlice","endOffset","TransactionTypes","computeAddress","Wordlist","locale","checkAbstract","mnemonic","words","wordlist","getWord","getWordIndex","lang","loadWords","check","langEn","register","wordlists","en","N","MasterSecret","HardenedBit","getUpperMask","bytes32","base58check","getWordlist","defaultPath","HDNode","parentFingerprint","chainCode","depth","mnemonicOrPath","checkNew","compressedPublicKey","path","IL","IR","ki","Ki","_addPoint","srcMnemonic","phrase","fingerprint","components","component","_derive","seedArray","password","entropyToMnemonic","mnemonicToEntropy","_fromSeed","mnemonicToSeed","extendedKey","salt","NFKD","iterations","keylen","hashAlgorithm","hLen","T","DK","block1","U","destPos","pbkdf2","bit","entropyBits","checksumMask","indices","remainingBits","checksumBits","isValidMnemonic","getAccountPath","getJsonWalletAddress","json","encseed","ethaddr","isCrowdsaleWallet","isKeystoreWallet","ripemd160","sha512","shuffled","random","arrayifyInteger","unarrayifyInteger","payload","child","isBytesLike","_decodeChildren","childOffset","decoded","_decode","consumed","lengthLength","recoverPublicKey","sig","rs","formatBytes32String","text","parseBytes32String","toUtf8String","AddressCoder","localName","writer","_throwError","writeValue","reader","readValue","Coder","AnonymousCoder","coder","dynamic","defaultValue","pack","coders","arrayValues","unique","staticWriter","Writer","wordSize","dynamicWriter","updateFuncs","dynamicOffset","updateFunc","writeUpdatableValue","baseOffset","appendWriter","unpack","baseReader","subReader","offsetReader","baseType","uniqueNames","ArrayCoder","defaultChild","checkArgumentCount","_data","coerce","BooleanCoder","DynamicBytesCoder","writeBytes","readBytes","BytesCoder","FixedBytesCoder","size","NullCoder","NegativeOne","Zero","One","MaxUint256","NumberCoder","signed","maxUintValue","mask","bounds","Utf8ErrorFuncs","getUtf8CodePoints","onError","extraLength","overlongMask","nextChar","MISSING_CONTINUE","OUT_OF_RANGE","UTF16_SURROGATE","codePoint","StringCoder","TupleCoder","types","paramTypeBytes","paramTypeNumber","AbiCoder","coerceFunc","param","_getCoder","arrayChildren","arrayLength","allowLoose","Reader","_getWordSize","ParamType","_getWriter","loose","_getReader","defaultAbiCoder","checkResultErrors","checkErrors","childPath","_dataLength","_padding","hexConcat","_writeData","paddingOffset","_getValue","_offset","_coerceFunc","alignedLength","_peekBytes","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","populate","FormatTypes","sighash","minimal","full","paramTypeArray","fromObject","_isParamType","format","indexed","allowIndexed","fromString","isParamType","verifyType","node","originalParam","newNode","parent","state","allowType","allowParams","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","parseGas","gas","parseModifiers","constant","payable","stateMutability","verifyState","isConstructorFragment","parens","outputs","isFunctionFragment","returns","checkForbidden","fragment","isErrorFragment","regexIdentifier","id","LogDescription","Description","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","wrapAccessError","property","wrap","Interface","fragments","abi","filter","getStatic","bucket","deploy","functions","events","nameOrSignatureOrSighash","getSighash","matching","nameOrSignatureOrTopic","topichash","getEventTopic","getFunction","getError","_","eventFragment","getEvent","_abiCoder","_encodeParams","_decodeParams","functionFragment","errorArgs","errorName","errorSignature","selector","builtin","method","topics","encodeTopic","pop","dataTypes","dataValues","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","tx","topic","decodeEventLog","hexData","errorFragment","_isInterface","getPrototypeOf","opaque","bigint","boolean","number","_isFrozen","isFrozen","_deepCopy","item","deepCopy","resolveProperties","promises","Promise","resolve","then","all","results","allowedTransactionKeys","forwardErrors","Signer","blockTag","_checkProvider","provider","getBalance","getTransactionCount","transaction","checkTransaction","estimateGas","populateTransaction","signTransaction","signedTx","sendTransaction","getNetwork","network","chainId","getGasPrice","getFeeData","resolveName","shallowCopy","to","__awaiter","catch","hasEip1559","maxFeePerGas","maxPriorityFeePerGas","gasPrice","feeData","gasLimit","getChainId","_isSigner","VoidSigner","_fail","domain","isAddress","getIcapAddress","base36","getContractAddress","stripZeros","getCreate2Address","initCodeHash","isBigNumberish","isBigNumber","AddressZero","Two","WeiPerEther","MinInt256","MaxInt256","HashZero","items","objects","Provider","getBlock","baseFeePerGas","eventName","listener","on","_isProvider","start","accessSetify","addr","storageKeys","storageKey","accessListify","sort","localeCompare","accessList","customData","ccipReadEnabled","resolver","nameOrPromise","resolveAddresses","paramType","reject","contract","overrides","signer","override","resolvedAddress","resolved","interface","encodeFunctionData","ro","intrinsic","roValue","leftovers","addContractWait","wait","bind","confirmations","receipt","logs","event","parsed","parseLog","eventSignature","removeListener","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","signerOrProvider","deployTransaction","_deployed","decodeFunctionResult","buildDefault","txRequest","buildSend","getEventTag","RunningEvent","tag","_listeners","once","done","listenerCount","argsCopy","setTimeout","ErrorRunningEvent","FragmentRunningEvent","contractInterface","decodeError","WildcardRunningEvent","BaseContract","addressOrName","Contract","isSigner","isProvider","uniqueFilters","filters","encodeFilterTopics","uniqueSignatures","callStatic","buildPopulate","buildEstimate","signatures","_deployedPromise","getCode","contractAddress","deployed","runningEvent","_runningEvents","_normalizeRunningEvent","emit","_wrappedEmits","_checkRunningEvents","prepareEvent","addListener","wrappedEmit","_wrapEvent","getEmit","fromBlockOrBlockhash","toBlock","_getRunningEvent","fromBlock","getLogs","_addEventListener","run","listeners","removeAllListeners","isInterface","isIndexed","ContractFactory","bytecode","bytecodeHex","encodeDeploy","unsignedTx","getDeployTransaction","getContract","compilerOutput","evm","getInterface","padding","hexTrue","hexFalse","domainFieldTypes","verifyingContract","domainFieldNames","checkString","domainChecks","getBaseEncoder","width","boundsUpper","boundsLower","padOffset","hexPadRight","encodeType","fields","TypedDataEncoder","links","parents","subtypes","field","primaryTypes","checkCircular","found","subtype","primaryType","st","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","encodeData","hashStruct","callback","_visit","domainFields","EIP712Domain","hashDomain","ensCache","visit","domainValues","domainTypes","typesWithDomain","codePoints","checkProperties","properties","anyGlobal","self","window","global","getGlobal","crypto","msCrypto","randomBytes","getRandomValues","buffer","regexBytes","regexNumber","regexArray","_pack","tight","escapeChar","_toEscapedUtf8String","handleAddress","handleNumber","transactionFields","maxLength","numeric","recoverAddress","formatNumber","formatAccessList","_serializeEip1559","RLP","_serializeEip2930","_serialize","raw","fieldInfo","serialize","transactionType","_parseEipSignature","recid","rawTransaction","_parse","_parseEip2930","_parseEip1559","LangEn","looseArrayify","hexString","zpad","getPassword","NFKC","searchPath","currentChild","matchingChild","uuidV4","hasMnemonic","KeystoreAccount","_isKeystoreAccount","_getAccount","ciphertext","iv","counter","aes","decrypt","_decrypt","mnemonicKey","account","mnemonicCiphertext","mnemonicIv","mnemonicCounter","mnemonicAesCtr","derivePath","pbkdf2Sync","passwordBytes","dkLen","prfFunc","_pbkdf2","_computeKdfKey","pbkdf2Func","scryptFunc","progressCallback","kdf","prf","CrowdsaleAccount","_isCrowdsaleAccount","encryptedSeed","aesCbc","seedHex","decryptJsonWallet","decryptCrowdsale","scrypt","decryptKeystore","decryptJsonWalletSync","decryptKeystoreSync","Wallet","fromMnemonic","_mnemonic","_signingKey","signDigest","joinSignature","_TypedDataEncoder","populated","client","uuidRandom","uuid","derivedKey","macPrefix","encrypt","mac","Crypto","cipher","cipherparams","kdfparams","dklen","now","Date","timestamp","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","gethFilename","encryptKeystore","extraEntropy","verifyMessage","verifyTypedData","getUrl","href","request","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetch","response","arrayBuffer","statusCode","status","statusMessage","statusText","staller","duration","bodyify","_fetchData","connection","processFunc","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","errorPassThrough","allow304","timeout","allowGzip","user","allowInsecureAuthentication","authorization","base64Encode","reData","dataMatch","base64Decode","SERVER_ERROR","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","TIMEOUT","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","serverError","throttleRetry","race","fetchJson","updated","poll","ceiling","interval","retryLimit","oncePoll","onceBlock"],"sourceRoot":""}